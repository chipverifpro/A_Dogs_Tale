Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Overlay.shader:1-4
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

---
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Masking.shader:2-4
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

---
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile-2-Pass.shader:1-4
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

---
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile.shader:2-4
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

---
Assets/TextMesh Pro/Shaders/TMP_SDF-Surface-Mobile.shader:1-4
// Simplified version of the SDF Surface shader :
// - No support for Bevel, Bump or envmap
// - Diffuse only lighting
// - Fully supports only 1 directional light. Other lights can affect it, but it will be per-vertex/SH.

---
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile SSD.shader:2-4
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

---
Assets/A_Dogs_Tale/Assets/Scripts/ObjectDirectory.cs:6-8
    // This is a catalog of all the objects and scripts in the game for all the
    // modules to share.  They only need a single reference to Directory to find
    // any other object.

---
Assets/A_Dogs_Tale/Assets/Scripts/Battle/PlayerCombatInput.cs:91-93
        // your existing touch/mouse code...
        // After you compute pos and call HandlePointer(down, up, pos) as you do now,
        // also add a "while dragging" visual update:

---
Assets/A_Dogs_Tale/Assets/Scripts/Battle/BattleAgent.cs:38-46
//IDEAS:
// Limit rotate speed, show rotation travel by rounded arrows
// Switch from straight target arrow to curved when power-up
// Combine functions into fewer classes.  Simplify.
// Show limits that move-in/out can be, and player's position within the range
// Effects for hit / miss
// Add keyboard controls
// Turn player in direction of travel, exposing side to enemy
// Show block

---
Assets/A_Dogs_Tale/Assets/Scripts/HeadsUpDisplay/BottomBanner.cs:43-46
            //  BottomBannerCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
            //  var scaler = c.GetComponent<CanvasScaler>();
            //  scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            //  scaler.referenceResolution = new Vector2(800, 800);

---
Assets/A_Dogs_Tale/Assets/Scripts/HeadsUpDisplay/BottomBanner.cs:48-50
        //else
        //{
        //canvas = go.GetComponent<Canvas>();

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/SniffModeVisuals.cs:66-69
    // This parameter is not implemented.  See comment in the code later in this file.
    //[Header("ScentFog layer")]
    //[Tooltip("Brighten scent fog in sniff mode.")]
    //public float sniffFogBoost = 1.5f;

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/SniffModeVisuals.cs:147-149
        // Apply global shader property for fog boost
        //if (sniffFogBoost != 1.0)
        //    Shader.SetGlobalFloat("_SniffFogBoost", enabled ? sniffFogBoost : 1.0f);

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/SniffModeVisuals.cs:151-154
        // NOTE: to use the sniffFogBoost above...
        // In your fog material’s shader (ShaderGraph or HLSL), multiply your final output
        // by this global float:
        //

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:130-132
    // monitor for changes to who or what is visualized, then clear/update/redraw
    // (this allows developer to change settings on-the-fly and the visuals track that)
    // Normally the redraw could be specified at the place the change is made.

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:393-399
        // Before first pass, initialize flag about scents which are stable.  Any change will set this false.
 //       for (int i = 0; i < dir.scentRegistry.knownScentSources.Count; i++)
 //       {
 //           var scentSource = dir.scentRegistry.knownScentSources[i];
 //           scentSource.scentNextStabilized = true;
 //       }
        // FIRST PASS: compute deltas and accumulate into airNextDelta / groundNextDelta

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:446-449
     //           if (scent.agent.agentScentSource == null) {Debug.LogWarning($"ScentAirGround: scent.agent.agentScentSource is null for agentId {scent.agentId} in cell at {cell.pos3d}. Skipping scent processing.");
     //               continue;}   // scent source missing, skip further processing
     //           if (scent.agent.agentScentSource.scentStabilized == true) {Debug.Log($"ScentAirGround: scent.agentId {scent.agentId} in cell at {cell.pos3d} is stabilized, skipping processing.");
     //               continue;}   // both layers stable, skip further processing

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:546-548
                // propogate changes we calculated in first pass above
                //float airDelta    = scent.airNextDelta;
                //float groundDelta = scent.groundNextDelta;

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:550-559
                // check for stabilization
 //               if ((Mathf.Abs(scent.airNextDelta) > practically_zero) || (Mathf.Abs(scent.groundNextDelta) > practically_zero))
 //               {
 //                   //Debug.Log($"ScentAirGround: Scent scentSource {scent.agentId} is changing. Air delta = {scent.airNextDelta}, Ground delta = {scent.groundNextDelta}");
 //                   scent.agent.agentScentSource.scentNextStabilized = false;   // scent still changing.
 //               } 
 //               else
 //               {
 //                   //Debug.Log($"ScentAirGround: Scent scentSource {scent.agentId} appears stable this step.  Air delta = {scent.airNextDelta}, Ground delta = {scent.groundNextDelta}");
 //               }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:581-591
            // after second pass, look for stabilied scents.
 //           for (int i = 0; i < gen.scentRegistry.knownScentSources.Count; i++)
 //           {
 //               var scentSource = gen.scentRegistry.knownScentSources[i];
 //               if ((scentSource.scentNextStabilized == true) &&
 //                  (scentSource.scentStabilized == false))
 //               {
 //                   Debug.Log($"ScentAirGround: Scent scentSource {scentSource.agentId} has stabilized.");
 //                   scentSource.scentStabilized = true;
 //               }
 //           }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:606-612
        // Reset needed? We already reset these after changes applied.
        //               Also reset at initial creation.
        //               Could we have changed something elsewhere we shouldn't forget to apply?
        //anyScentAirChanged = false;
        //anyScentGroundChanged = false;
        //anyScentAirCreated = false;
        //anyScentGroundCreated = false;

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:631-633
                // skip visualization if both layers are stable
 //               if (scent.agent.agentScentSource.scentStabilized)
 //                   continue;   // both layers stable, skip further processing

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:635-637
                // check for visible and significant intensity changes:
                //          scent is visible AND (change since last update large enough
                //                                OR changed to exactly 0)

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:780-784
 //       if (scentSource.scentStabilized)
 //       {
 //           Debug.LogWarning($"DepositScentToCell: scentSource {scentSource.agentId} is stabilized; no further scent will be deposited.");
 //           return;
 //       }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:946-948
        // Easiest way: just run one StepOnce with dt=0 to push colors
        // or set a flag that your ScentUpdate coroutine checks:
        // e.g., needsFullRefresh = true;

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:44-46
    // Display name:
    // - Category-level initially (e.g., "Food")
    // - Specific after identification (e.g., "Hot Dog")

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:292-296
        // TODO: Implement integration with your ScentSystem & Cell layout:
        // - For the given cell, find all agentIds contributing scent there.
        // - Map agentId -> ScentSource via this registry.
        // - Compute airStrength / groundStrength / combinedStrength.
        // For now, just return an empty list stub.

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:331-334
        //if (scentSource == null)
        //{
        //    return;
        //}

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:362-364
        // TODO: Hook up to dog AI:
        // - Some dogs may lose concentration and wander toward this scent
        //   if strength * sensitivityBoost crosses a per-dog threshold.

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:397-399
        // TODO: Implement load logic:
        // - Deserialize into 'knownScents'
        // - Call RebuildLookup()

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Globals.cs:38-41
    // These global lists help lookup things quickly
    // These are handled in Room class now.
    //public HashSet<Vector2Int> floor_hash_map = new();
    //public HashSet<Vector2Int> wall_hash_map = new();

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Globals.cs:62-65
    //       Vector2Int.up + Vector2Int.left,
    //       Vector2Int.up + Vector2Int.right,
    //       Vector2Int.down + Vector2Int.left,
    //       Vector2Int.down + Vector2Int.right };

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Globals.cs:74-76
    // Sets the agent id to a unique number, and returns that value.
    // Can be called without an agent, and caller must assign the number themselves.
    // ID is used to (a) determine equivalence match, (b) track id of some event in a list.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:150-157
    // RegenerateDungeon is the main coroutine that handles dungeon generation.
    // It orchestrates the various steps involved in creating the dungeon layout.
    // Step 0: Select settings
    // Step 1: Initialize the dungeon
    // Step 2: Place rooms (ScatterRooms or CellularAutomata)
    // Step 3: Convert rooms to a list of floor tiles (ConvertRectToRoomPoints or findRoomTiles for CA)
    // Step 4: Combine overlapping rooms (MergeOverlappingRooms)
    // Step 5: Connect rooms by corridors (DrawCorridors)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:258-262
            // TAVERN
            //            if (tavern.enabled)
            //            {
            //                yield return StartCoroutine(BuildTavern(tm: null));
            //            }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:545-547
            //bool printonce = true;
            // CELL_VERSION
            //Debug.Log("DrawMapByRooms: room " + room.my_room_number + " size: " + room.cells.Count);

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:721-725
        //Debug.Log("SetTilemapWithTransforms");
        //Debug.Log($"pos     ={pos.ToString()}");
        //Debug.Log($"scale   ={scale.ToString()}");
        //Debug.Log($"offset  ={offset.ToString()}");
        //Debug.Log($"rotation={rotation.ToString()}");

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:1123-1126
    // =======================================================
    // helper routines
    // =======================================================
    //  Extra functions

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/NeighborCache.cs:94-96
    // Square:
    // - includeDiagonals = true  => Chebyshev distance (classic filled square or ring)
    // - includeDiagonals = false => axis-only (a cross): dx==0 xor dy==0, within radius (or exactly radius for border)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:123-126
    // Example of assigning a functiion to the delegates:
    //   Cell trapCell = new Cell(2, 3);
    //   trapCell.OnStep = (c) => Debug.Log($"Ouch! Trap triggered at {c.x},{c.y}!");
    //   trapCell.OnView = (c) => Debug.Log($"You see a suspicious floor tile at {c.x},{c.y}...");

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:128-130
    // Example of calling the delegates:
    //   currentCell.TriggerView();
    //   currentCell.TriggerStep();

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:143-145
    // NOTE: The above structure will replace these fields below.
    //public List<Vector2Int> tiles = new();
    //public List<Vector2Int> walls = new();

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:159-166
    // OLD style: quick lookup in multiple lists for floors, walls, heights.
    // HashSets allow fast check whether room contains something at a position.
    // See the functions below: bool IsTileInRoom(pos), bool IsWallInRoom(pos)
    // Dictionaries are also based on a hash but returns a value at that position.
    // int GetHeightInRoom_OLD(pos)
    //public HashSet<Vector2Int> floor_hash_room = new();
    //public HashSet<Vector2Int> wall_hash_room = new();
    //public Dictionary<Vector2Int, int> heights_lookup_room = new();

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:168-170
    // NEW style: After migrating to using class Cell instead of separate lists.
    // GetCellInRoom(pos) returns the index into this room's "cells" list.
    // on not finding the cell, function returns -1.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:234-238
            //Debug.Log($"Building cell_dictionary_room.");
            // Build dictionary once and keep it.
            //   Auto-regenerates if "cells" list length changes.
            //   Note that you must manually call ResetCellDictionary()
            //   yourself if you modify the list

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:258-260
    // NEW
    // simple helper lookup function for height.
    // Other fields could be done the same way.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:296-301
    // Set the color for the floor tiles in this room many ways...
    // room.setColorFloor(Color.white);        // White
    // room.setColorFloor(rgb: "#FF0000FF"); // Red
    // room.setColorFloor();                   // Bright Random
    // room.setColorFloor(highlight: false);   // Dark   Random
    // room.setColorFloor(highlight: true);    // Bright Random

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:388-390
        // Per-tile vertical rise given the slope angle.
        // If one grid step in XY equals 1 "height unit", set heightUnitsPerTile = 1.
        // If you quantize heights (e.g., 1 height unit = 0.01 meters), pass that scale in.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:393-398
        // (Optional) compute the maximum signed projection run from center to room edge
        // along the given direction; useful if you want to reason about max delta:
        // float hx = (b.width  - 1) * 0.5f;
        // float hy = (b.height - 1) * 0.5f;
        // float maxProjAbs = Mathf.Abs(dir.x) * hx + Mathf.Abs(dir.y) * hy;
        // float maxHeightDelta = slopePerTile * maxProjAbs;

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:486-488
        // Clamp extremes for stability.  leaves cliffs looking funky
        //pitchDeg = Mathf.Clamp(pitchDeg, -maxAbsAngleDeg, maxAbsAngleDeg);
        //rollDeg = Mathf.Clamp(rollDeg, -maxAbsAngleDeg, maxAbsAngleDeg);

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:596-599
    // UNUSED NEW
    // MoveRoom will shift a room in x,y,and z(height) directions.
    // If allow_collision = false, room doesn't move when it collides with another room.
    // TODO: check for collision.  Also allow rotation, scaling, growing?

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:179-183
                // Out of inline capacity: fall back to segment building path by forcing finalize to SegmentVec
                // We temporarily append "at the end" (not sorted) and let FinalizeColumns fix it.
                // Reuse last slot to mark overflow; we'll re-sort later.
                // For correctness right now, replace the farthest z to keep n constant.
                // (Corner case; will be fixed in FinalizeColumns.)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:579-583
                        // If your world can have multiple segments at the same column height range,
                        // treat crossings between distinct segments as needing a barrier/rail.
                        // Here we use segmentIndex (valid when isSegment==true). If the current
                        // column also has segments and the current z lies in a different one than
                        // neighbor, count it as exposed. We need our own segment index at (x,y,z):

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:609-637
    // --------------------------
        // Adapters to YOUR data
        // --------------------------
        //
        // 1) If your heights are float, choose a scale (e.g., 100) and round: zInt = Mathf.RoundToInt(zFloat * scale).
        // 2) If your world is big, build per-chunk Heightfield instances (e.g., 64x64) and query only active chunks.
        //
        // Example usage in your pipeline:
        //
        //   // Prepare cells from your rooms:
        //   var tmp = new List<RoomCell>(totalCellCount);
        //   foreach (var room in rooms)
        //       foreach (var cell in room.tiles3D) // (x,y,height)
        //           tmp.Add(new RoomCell(cell.x, cell.y, HeightToInt(cell.height), room.id));
        //
        //   // Build
        //   var hf = Heightfield.BuildFromCells(tmp, worldWidth, worldHeight, cfg.minRoomHeight);
        //
        //   // During wall placement for a floor cell (x,y,zInt):
        //   NeighborMatch m;
        //   bool hasNeighbor = hf.HasAdjacentWithinThreshold(x, y, zInt, cfg.minRoomHeight, out m);
        //   if (!hasNeighbor) {
        //       // exposed side -> place wall
        //   } else {
        //       // Optional: decide based on room ids or m.isSegment (e.g., railing for stairwell)
        //   }
        //
        // Helper for float heights:
        // static int HeightToInt(float z) => Mathf.RoundToInt(z * 100f); // choose a scale that matches your thresholds

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/DoorModel.cs:48-50
    // Local owner room index (into your global rooms list) for reference/debug.
    // Not strictly required if the door lives inside the Room.doors list,
    // but helpful for cross-checks and when you cache doors globally.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/DisjointSetUnion.cs:3-7
//public static class DSU
//
// Simple Union-Find/Disjoint Set (DSU=Disjoint Set Union)
// Created by ChatGPT, for MergeOverlappingRooms function.
// Will probably re-write this using existing hashes.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering2DMap/Tilemap2D.cs:129-131
                // optional progress log
                //Debug.Log($"Cluster finder processed col {x} of {width}");
                //yield return null;

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering2DMap/Tilemap2D.cs:160-164
                                                         // Clear visuals;
                                                         //if (replacementTile != null)
                                                         //tilemap.SetTile(pos, replacementTile);
                                                         //else
                                                         //ClearTileAndNeighborWalls(tilemap, pos);

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering2DMap/Tilemap2D.cs:185-189
            // 1) Find Floor clusters
            // we already found the rooms, just filter them out for tiny ones.
            //rooms = new List<Room>();
            //yield return StartCoroutine(FindClustersCoroutine(map, FLOOR, rooms, tm: null));
            // 2) Remove the tiny ones by turning them into WALL

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering3D/HeightMap3DBuilder.cs:10-14
    //[Header("3D Build Settings")]
    //    public float unitHeight = 0.1f;             // world Y per step
    //    public bool useDiagonalCorners = true;
    //    public bool skipOrthogonalWhenDiagonal = true;
    //    public int perimeterWallSteps = 30; // height of perimeter walls in steps

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering3D/HeightMap3DBuilder.cs:46-48
        // Offset from tile center toward a corner (¼ cell each axis)
        //float ox = (east  ? +1f : -1f) * (cell.x * 0.25f);
        //float oz = (north ? +1f : -1f) * (cell.y * 0.25f); // grid.y maps to world Z

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering3D/HeightMap3DBuilder.cs:57-59
        // Length of a strip across the tile on a 45° diagonal (midpoint to midpoint):
        //float hx = cell.x * 0.5f;
        //float hz = cell.y * 0.5f;

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonBuildSettingsJson.cs:77-83
// Example usage:
//
// Save current settings
// settings.SaveToJsonFile("MyPreset");
//
// Load (overwrite current instance fields)
// settings.LoadFromJsonFileOverwrite("MyPreset");
---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonGUISelector.cs:80-86
        // ----- ENUM PATH (recommended) -----
        // Assumes your DungeonSettings contains:
        //   public RoomAlgorithm roomAlgorithm;
        //   public TunnelAlgorithm tunnelsAlgorithm;
        // …and the enums:
        //   public enum RoomAlgorithm { BSP, Cellular, Drunkard, PrefabRooms, … }
        //   public enum TunnelAlgorithm { Straight, LSystem, AStarCarve, … }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonGUISelector.cs:172-180
    // If you store strings in cfg instead of enums:
    // static void PopulateDropdownFromList(TMP_Dropdown dd, IList<string> items)
    // {
    //     dd.options.Clear();
    //     for (int i = 0; i < items.Count; i++)
    //         dd.options.Add(new TMP_Dropdown.OptionData(items[i]));
    //     dd.value = 0;
    //     dd.RefreshShownValue();
    // }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:20-22
        //BottomBanner.Show = cfg.showBuildProcess ? (Action<string>)BottomBanner.Show : (_)=>{};
        //packMap = new PackMap(cfg.mapWidth, cfg.mapHeight);
        //List<Room> rooms_temp = new(); // temporary Room list for compatibility with DrawMapByRooms

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:159-166
    //  IEnumerator Corridors_DrunkardsWalk()
    //  {
    //      BottomBanner.Show("Corridors: DrunkardsWalk");
    //      // 1) lay 'cfg.corridor.spineCount' biased random walks with width 'cfg.corridor.corridorWidth'
    //      // 2) optionally connect keypoints with loops
    //      // 3) write into PackMap.corridors and lock a 1-cell moat if you keep thin walls
    //      yield return null;
    //     }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:168-175
    //    IEnumerator Corridors_WanderingMST()
    //    {
    //        BottomBanner.Show("Corridors: WanderingMST");
    //        // 1) lay 'cfg.corridor.spineCount' biased random walks with width 'cfg.corridor.corridorWidth'
    //        // 2) connect keypoints with MST + add loops with probability cfg.corridor.loopChance
    //        // 3) write into PackMap.corridors and lock a 1-cell moat if you keep thin walls
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:189-195
    //    IEnumerator Seed_AlongCorridors()
    //    {
    //        BottomBanner.Show("Seeding: AlongCorridors");
    //        // place seeds along corridor sides every cfg.seed.spacing with jitter cfg.seed.jitter
    //        // alternate left/right by cfg.seed.alternateSides
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:209-216
    //    IEnumerator Grow_CreditWavefront()
    //    {
    //        BottomBanner.Show("Growth: CreditWavefront");
    //        // each room gets random credit in [cfg.grow.areaCreditMin..Max]
    //        // round-robin claimable frontier respecting moat = cfg.grow.wallMoat
    //        // split if area>cfg.grow.splitArea or aspect>cfg.grow.splitAspect
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:230-235
    //IEnumerator Scraps_VoronoiFill()
    //{
    //    BottomBanner.Show("Scraps: VoronoiFill");
    //    // assign leftovers to nearest room with 1-cell peel for walls; tiny islands -> closets
    //    yield return null;
    //}

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:689-691
        // 3) For each anchor, choose a side (left/right normal to corridor),
        //    find the edge of the corridor, offset off the corridor by moat+1,
        //    and plant a single seed cell there (unless it is a bad spot).

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:711-714
            // a is the anchor location
            // n is the perpendicular direction (already randomized left or right)
            //   (second pass we will invert this and try the other side)
            // s is the location after stepping several times in the n direction away from anchor

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:765-769
    // ROOM READY
    // Grow_CreditWavefrontStrips() repeatedly expands rooms in one direction by a full length row or column.
    //   This keeps rooms rectangular (as opposed to just CreditWavefront (obsolete/removed)).
    // allowedRoomIds list can optionally be provided to limit which rooms to grow.
    //   allowedRoomIds is unused in first pass of growth.  Used in repeated passes of growth to only grow new seeds.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:773-777
        // PRECONDITIONS:
        // - rooms is a global variable that contains all Room objects
        // - Each Room has at least one seed Cell in cellGrid[,] with cell.roomId = room.id
        // - Corridors already painted (cell.isCorridor = true)
        // - We will preserve an N-cell wall moat (N = cfg.grow.wallMoat) around rooms & corridors

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:958-964
    // ======================= Scraps: VoronoiFill (with 1-cell peel) =======================
    // Usage:
    //   yield return StartCoroutine(Scraps_VoronoiFill(
    //       moatOverride: -1,      // -1 => use cfg.grow.wallMoat
    //       useCentroids: true,    // false => use first seed cell as proxy
    //       peelIterations: 1,     // run peel pass N times (1–2 is enough)
    //       yieldEvery: 2048));

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1139-1149
    // ======================= Scraps: Seed & Grow Until Packed =======================
    // Usage example:
    //   yield return StartCoroutine(Scraps_SeedAndGrowUntilPacked(
    //       mode: ScrapSeedMode.PerimeterEveryN,
    //       perimeterSpacing: 10,
    //       randomSeedsPerRegion: 3,
    //       randomMinSpacing: 6,
    //       maxRounds: 6,
    //       moatOverride: -1,             // -1 uses cfg.grow.wallMoat
    //       yieldEvery: 2048
    //   ));

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1307-1309
    // ROOM READY
    // Allocate the memory for cellGrid.  Fill it with cells containing location only.
    //   Do it once at the beginning.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1396-1398
    // ROOM READY
    // used in Scraps_SeedAndGrowUntilPacked() to verify seeds are far enough apart.
    // simple Manhattan distance (delta x + delta y) between two points.    

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1402-1404
    // =========================================================
    // ==================== HELPERS ============================
    // =========================================================

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1411-1413
    // ROOM READY
    // used in Scraps_VoronoiFill.
    // returns true if (x,y is at least moatCells away from a corridor)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1426-1428
    // ROOM READY
    // used in Scraps_VoronoiFill.
    // returns true if (x,y) is at least moatCells away from non-empty cells (other rooms and any corridor).

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1443-1446
    // ROOM READY
    // used in Scraps_VoroniFill during peel.
    // determines if we are adjacent to a room or corridor (with moat between).
    // variables are named weird: label=?  my=label[x,y] ? what do these do?

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1518-1523
    // ROOM READY
    // Checks if the room is big enough and stretched enough to split.
    // Determines where to cut the room.
    // Performs the cut: moat cells removed, left side kept in old room, right side moved to a new room.
    // Add new room to master rooms list
    // Update the screen, calculate new bounds and frontiers.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1674-1676
    // ROOMS READY
    // Builds one HashSet frontier for room (ri) containing all the cells that the room
    //   could grow to.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1700-1704
    // ROOM READY
    // score depends on the length-to-height ratio modified by the targetAsp parameter,
    //                  the cooldown penalty for that direction,
    //                  a preference for the short axis.
    // Return sides in best-first order: 0:E,1:W,2:N,3:S

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1734-1737
    // ROOM READY
    // Try to grow a full 1-cell strip on the chosen side.
    // Returns true if the whole strip was claimed.
    // side: 0=E (x=max+1), 1=W (x=min-1), 2=N (y=max+1), 3=S (y=min-1)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1790-1794
    // Unused.
    // Wavefront helpers (compactness-biased pick).
    // Selects best cell in frontier, based on score:
    //    SCORE: -3: not close to corridor
    //           +2: adjacent to more cells in the same room

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1825-1828
    // ROOM READY
    // Nearly the same as Can Place Seed.  Can easily merge functionality.  TODO.
    // Only difference is that ri is passed in and may return true if the 
    //   room already owns the cell or neighbors which is useful here.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1850-1852
    // ROOM READY
    // Grabs the cell from cellGrid, and adds it to a given room (ri).
    // Does not check previous owner except to determine if it already owns it.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1864-1866
    // ROOM READY
    // Never used, algorithm instead removes duplicates later.
    // Looks for an existing Room that is a duplicate of the one being added.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1878-1880
    // ROOM READY
    // Never used, algorithm instead removes duplicates later.
    // Looks for an existing Cell that is a duplicate of the one being added.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1914-1916
    // ROOM READY
    // Searches a list of cells and removes duplicates matching X,Y,AND Z (usually list is of a single room)
    // See the function RemoveDuplicateCellsFromAllRooms() for the global search.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2006-2010
    // ROOM READY
    // Pick a tangent direction at (x,y) by counting how many contiguous corridor
    // cells exist to the Left/Right/Down/Up (L/R/D/U). Wider corridors are handled
    // because we look past a single neighbor. Returns (1,0) for horizontal,
    // (0,1) for vertical, or Vector2Int.zero if nothing usable is found.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2045-2051
    // ROOMS ready
    // Returns the number of cells that continue to be a corridor in a given
    //   direction (d) from starting point (s).
    // Only looks as far as maxSteps.
    // Used in Seed_AlongCorridors via the PickTangentDir and CountCorridorNeighbors functions
    //   to determine which directions the corridor goes from a given location
    //   (since corridors can be wide we need to look farther).

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2087-2089
    // CONVERTED to ROOM
    // Used by Seed_AlongCorridors algorithm and Scraps_SeedAndGrowUntilPacked algorithm
    // Checks if location is unoccupied and moat cells around it are clear also.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2112-2114
    // CONVERTED to ROOM
    // Used by Seed_AlongCorridors algorithm
    // assumes location is a valid seed location = passed CanPlaceSeed()

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2465-2467
            // Uncomment if you want to track reference sharing issues:
            // Debug.Log($"Cell {a.pos}: instance differs from cellGrid reference (values compared above).");
            // (No diff increment; value equality is what matters.)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomCorridors.cs:12-14
    // NEW
    // Iterates through all unconnected rooms.  Finds a short corridor between two closest super-rooms and
    // generates that corridor as a new room.  Connects both ends to the rooms, making a bigger super-room.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomCorridors.cs:47-49
                // Find two closest rooms (i and j),
                // and a point in each close to the other (close_i, close_j)
                // (not guaranteed to be THE closest, but good enough for room connections)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomGrowthAlgorithms.cs:8-14
    // Cellular Automata Algorithm:
    // 1. Fill a 2D map with random or noisy structured data (perlin noise).
    // 1a. Threshold the 2D map into only floors and walls
    // 2. Run the game of life on the cells using rules about survivability based on number of neighbors,
    //    through several iterations (smoothes out areas, gives structure to noise)
    // 3. Clean up result (remove tiny areas (rooms or rocks), replace solid wall fields with void.
    // 4. Convert result into Rooms.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomGrowthAlgorithms.cs:41-43
    // RandomFillMap with either white noise or Perlin-based 'noise'.
    //   For perlin, two different wavelengths are weighted and averaged to get
    //   (low wavelength) odd shaped rooms + (higher wavelength) bumps and rocks especially around room borders

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomGrowthAlgorithms.cs:80-82
    // RunSimulationStep runs the Cellular Automata routine (aka the game of Life), where
    // cells either die or grow based on the number of neighbors they have.
    // Results in smoothing out the noise input into useful cavern shapes.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/LineGenerators.cs:6-18
    // --------- Corridor line algorithms ----------
    // These return a list of points, which the DrawCorrior function will follow
    // while handling the width and slope to generate a corridor Room:
    //
    //   ORTHOGONAL (straight in cardinal directions only, one 90 degree bend)
    //   BRESENHAM (straight direct between end points)
    //   NOISY BRESENHAM (slightly wiggly version of a straight line)
    //   ORGANIC (kinda jiggles while going 45 degrees and then vertical or horizontal)
    //   BEZIER (curved quadratic form with two random control points)
    //
    //   future: STAIRS in versions that are straight, square, octagon, or switchback
    //           primarily for going up and down one or more a vertical floors
    //   future: LADDER (vertical only), or PIT or SHAFT or ELEVATOR or...

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/LineGenerators.cs:142-144
    // Organic Line algorithm: creates a wonky, wiggly line between two points.
    // Tends to first do a 45 degree diagonal and then switches to horizontal or vertical.
    // Not too bad for short lines as the jagginess can be good.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/DoorGenerators.cs:430-432
            //Debug.Log($"Candidate {num}: @{c.x},{c.y} {c.dir} placed={c.placed} A={c.roomId} -> B={c.targetRoomId}");
            //Debug.Log($"room {c.roomId} : doors = {rooms[c.roomId].doors.Count}");
            //Debug.Log($"{c.cellA.x},{c.cellA.y} doors={c.cellA.doors} -> {c.cellB.x},{c.cellB.y} doors={c.cellB.doors}");

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomScatterAlgortithms.cs:6-20
// ---------------------- Room Scatter Algorithms ----------------
// ScatterRoom handles either rectangular or oval rooms that are randomly scattered.
// They can be configured to overlap or not.  Overlaps can either merge into an odd
// shaped room, or have different elevations allowing one above the other, or if
// vertical distance is small enough, they will have an elevation between them (cliff
// or steps).
//
// Future: COMPACT: rooms will all touch each other in a contiguous area.
//         They may have thin or thick walls.
// Future: Rooms may have functional purposes and have specific connection rules,
//         like Tavern which has a common area, a service area, and a private area,
//         each consisting of several named rooms.
//
// -------------------- room rect functions -----------------------------
// This file also contains a bunch of routines that deal with room_rects.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomScatterAlgortithms.cs:86-92
    // Returns true if the proposed room bounds fit inside the world according to config flags.
    // (1) cfg.ovalRooms   — RectInt room treated as an inscribed axis-aligned ellipse when true.
    // (2) cfg.roundWorld — world bounds are an axis-aligned ellipse inscribed in the map when true;
    //                       otherwise world is the rectangular map.
    // "samples" controls boundary sampling for oval-in-oval; "margin" shrinks world a bit to avoid edge bleed.
    // 
    // Works for: Rect in Rect, Oval in Rect, Rect in Oval, and Oval in Oval.

---
Assets/A_Dogs_Tale/Assets/Scripts/Main Menu/SceneFader.cs:120-123
        // LEGACY:
        //MusicPlayer musicPlayer = FindFirstObjectByType<MusicPlayer>();
        //if (musicPlayer != null)
        //    musicPlayer.StartMusic(musicPlayer.exploreAudioFileName, fadeOut:true, fadeIn:false);

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:334-336
                /*
                // Safer handling of kind mismatch
                // Create a sibling layer name to keep data sane (or you can abort)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:550-554
        // Optional: validate before trying to build
        //if (!elementStore.TryGetArchetype(inst.archetypeId, out _)) {
        //    Debug.LogError("AddScentGround: archetype {inst.architypeId} not registered. Register it before calling AddScentGround.");
        //    return -1;
        //}

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ManufactureGO.cs:203-205
            // Optional: also set children
            //foreach (Transform t in go.transform)
            //    t.gameObject.layer = fogLayer;

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ManufactureGO.cs:222-224
        //BuildAll(); // DEBUG: rebuild everything
        //return;
        //Debug.Log("ManufactureGO: Applying pending updates to manufactured GameObjects.");

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:26-29
                                                   // (0,0)           : continuous loop
                                                   // (x,y) where x<y : wait between x and y seconds before repeat
                                                   // (x,y) where x=y : wait exactly x seconds before repeat         
                                                   // (x,y) where x>y : no looping, play once

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:55-59
// class AudioCatalog contains a master list of all audio available
//  to the game.  All that is needed is to call PlayClip() with
//  the name of the track, and it handles everything else.
// It will eventually import this from some configuration file,
//  maybe a .csv, a .json, or from the directory itself.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:127-130
            // intervalRange(0,0)           : continuous loop, no gap (FYI: loop is managed by Unity automagically)
            // intervalRange(x,y) where x<y : wait between x and y seconds before repeat
            // intervalRange(x,y) where x=y : wait exactly x seconds before repeat         
            // intervalRange(x,y) where x>y : no looping, play once (DEFAULT if null)

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:217-220
            // Verify is the file is valid without loading it.
            // This does technically instantiate the AudioClip object but doesn’t decode or keep PCM data
            //   in memory if you unload immediately.  For small validation runs at startup, this is perfectly
            //   fine — it’s cheap and reliable.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:236-238
        // new clipCfg is ready to add to catalog, but first make sure it is unique...
        // --- Determine if clipCfg already existed ---
        // Find if the clip is already in the catalog (by name)

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:260-262
    // Note: UnloadClipCfg() does NOT remove the clipCfg from the catalog list, do that separately.
    // UnloadClipCfg() stops any running tasks, unloads audio data, and cleans up references.
    // Note that much of this is done as coroutines which will complete over time.  No need to wait for any of that to finish.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:63-69
    // PlayClip() finds the audio clip in the master catalog (clipCfgList),
    //  configures everything, and then launches the Coroutine
    //  PlayWithInterval() which starts the play and follows
    //  it through it's lifecycle.
    // Each entry in the master catalog (a unique "clipCfg") maintains
    //  a list of currently playing copies so they can be ended
    //  anytime needed.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:170-174
    // PlayWithInterval() will handle all cases of plaing a track.
    //   whether single time, continuous repeat, or
    //   repeat forever with fixed or random pauses between.
    // A TaskInfo structure is maintained so that tasks and audio 
    //   can be stopped if needed (ie. scene change, sound source disappears, etc)

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:193-196
                    // a continuously looping track will never end,
                    //  so go ahead and exit this task.  The taskInfo
                    //  will remain as a means of manually stopping it.
                    //Debug.Log($"[PlayWithInterval] '{clipCfg.name}' monitoring task ends since auto loop playing is active.");

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:251-256
    // StopClips() has several options...
    //  Stop everything
    //  Stop all with a particular name
    //  Stop all on a particular channel (ie Music, UI, SFX, ...)
    //  Stop all from a particular GameObject
    //  Stop all from all temporary GameObjects

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:258-261
    // Can end in one of these styles:
    //  Immediate cutoff of playing. (fadeOut = 0)
    //  Fade out and then stop.      (fadeOut = # seconds)
    //  Allow to finish in-progress track, but don't start again. (fadeOut < 0)

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:295-304
    // Don't call coroutine AudioTaskStop() directly, use StopClips() above
    //   which applies a lookup filter to select tasks and remove them from the active
    //   list, and send control of them here to be managed until they are done.
    // task.AudioTaskStop():  Corourtine that stops managed track by stopping existing driver
    //   coroutine, then it takes over managing the track until it has stopped. Finally
    //   it destroys the GameObject if it is a temporary one created just for this audio.
    // Can end in one of these styles:
    //   Immediate cutoff of playing. (fadeOut = 0)
    //   Fade out and then stop.      (fadeOut = # seconds)
    //   Allow to finish in-progress track, but don't start again. (fadeOut < 0)

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PackFormations.cs:72-75
        // return the offset vector for the given formation and position in pack.
        // Assumes position_in_pack is 0 for leader, 1..n for followers.
        // Assumes leader facing north.  Rotation to be applied later.
        // some formations depend on number in pack.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:29-31
    //public Vector2 pos2;          // XY or XZ (depending on useXZPlane)
    //public float yawDeg;          // facing yaw in degrees (around Z for XY, around Y for XZ)
    //public int floorHeight = 1;   // height of current tile.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:155-157
                                //agent.trail = GetComponent<BreadcrumbTrail>();
                                //BuildPackObjects(3);    // This exists in Pack class.
        //pack.packList.Add(pack.PackLeader); // leader agent needs to be added to the packlist.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:173-183
            //    
            //    dir.scents.AddScentToCell(player_cell,
            //                                    agentId: 1,
            //                                    airAmount: 1f,
            //                                    groundAmount: .1f);
                //Debug.LogError($"[AddScent] Player is in cell {agent.pos2.x}, {agent.pos2.y}, room {player_cell.room_number}");
                //dir.scents.AddToNextScentIntensity(
                //    player_cell,        // cell
                //    1,                  // phony agent_id  // TODO: link to real agent id
                //    set_intensity: 1.0f // set a value, not add a value
                //);

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:234-236
    // Change which agent the player is controlling...
    // old leader agent becomes a follower, and new agent becomes leader.
    // new agent moves to front of pack order.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:9-12
    // ==============================================================
    // An Agent is a character.  Specific types inherit these behaviors
    //   PlayerAgent is a member of the player's party.
    //   NPCAgent is a non-player-charactger (friendly / neutral / hostile).

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:39-42
    // while in a pack formation, these are the target positions as calculated from leader's position.
    //public Vector2 formationTargetPos;     // position we should be at in formation
    //public float formationTargetYaw;     // direction we should be facing in formation
    //public Vector2 formationCrumbPos;      // allows finding Crumbs to continue following while holding formation.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:135-140
                    //Debug.Log($"Depositing scent from AgentId = {id} at {pos2_int}: air += {agentScentSource.airDepositRate}, ground += {agentScentSource.groundDepositRate}");
 //                   if (agentScentSource.scentStabilized == true)
 //                   {
 //                       agentScentSource.scentStabilized = false;
 //                       Debug.Log($"AgentScentEmmiter: AgentId {id} scent unstabilized due to new deposit.");
 //                   }

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:302-304
                    //if (next_formationCrumb.yawDeg == pack.PackLeader.yawDeg)
                        //return;
                    //Debug.LogWarning($"Two sequential crumbs on top of each other.  At leader, who isn't moving.");

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:560-563
        // if you keep a generator / grid on Agent:
        //if (!DungeonGenerator.Check(pack.gen, "gen", this)) skipHeight = true;
        //if (!DungeonGenerator.Check(pack.gen.cellGrid, "gen.cellGrid", this)) skipHeight = true;
        //if (!DungeonGenerator.Check(pack.gen.rooms, "gen.rooms", this)) skipHeight = true;

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:583-585
        // useXZPlane is always true, eliminated it.
//        if (useXZPlane)
//        {

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:602-619
//        }
//        else
//        {
//            Vector3 t; // = transform.position; // not necessary, we overwrite this value completely
//            Vector2 t_World = Map_to_World(agent.pos2);
//            t.x = t_World.x; t.y = t_World.y; // XY location
//            t.z = agent.height + 1;
//            agent.transform.position = t;
//            agent.targetYawDeg = agent.yawDeg;
//            TurnTowards(ref agent.yawDeg, agent.prevYawDeg, agent.targetYawDeg, agent.turnSpeedDegPerSec);
//            agent.prevYawDeg = agent.yawDeg;
//            agent.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Z for XY
//            if (pack.player.agent == agent)
//            {
//                pack.player.transform.position = t;
//                pack.player.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Y for 3D
//            }                                                                                       //pack.player.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Z for XY
//        }

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:707-713
    // Assumptions:
    // - agentPos is in tile/grid coordinates (1 unit per cell) on the XZ plane → (x,z) == (agentPos.x, agentPos.y)
    // - cellGrid[x,y] gives you the Room.Cell that contains:
    //     int height;                // base floor height at the cell center
    //     Quaternion tiltFloor;      // tilt of the floor plane
    // - Y is world up.
    // cellGrid dimensions are W x H

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:736-738
        // Point X we want: (agentPos.x, y, agentPos.y). Solve n · (X - P0) = 0 for y.
        // n.x*(x - P0.x) + n.y*(y - P0.y) + n.z*(z - P0.z) = 0
        // => y = P0.y - (n.x*(x-P0.x) + n.z*(z-P0.z)) / n.y

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerControls/Inputs.cs:8-10
    //[Header("Leader & Routing")]
    //public Transform leader;                    // your leader's Transform
    //public Player player;              // optional: your routing component with SetDestination(Vector3)

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/BreadcrumbTrail.cs:203-205
                // we located the last crumb this follower ate.  Now give follower the next one    
                //crumb_index--;
                //agent.next_actualCrumb = crumbs[crumb_index];

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:31-34
            //leaderTravelling = false; // if player is turning, stop travelling to click target
            // commit rotation ALWAYS (even if thrust == 0)
            //if (useXZPlane) agent.transform.rotation = Quaternion.Euler(0f, agent.yawDeg + yawCorrection, 0f);
            //else agent.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection);

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:159-161
            // debug display:
            //var c = gen.cellGrid[from_i, from_j];                                     // Debug
            //Debug.Log($"pos={from},{from}  Walls={c.walls}, Doors={c.doors}");    // Debug

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:272-274
    // Prevent walking into the end of a thin wall:
    //   If we are close to an edge of the current cell, then block to the left and right if there is a wall end there.
    //   This also prevents walking off the edge of a door, which is covered as a subset of this check.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:449-451
        //Debug.Log($"startWorld=({startWorld.x},{startWorld.z}) dirWorld=({dirWorld.x},{dirWorld.z}) in cell {cellXY} of room {room.my_room_number}");
        //Debug.Log($"   Checking diagonal in cell {cellXY} walls={cell.walls} doors={cell.doors}");
        // Determine which diagonal corner this cell blocks (two walls, no doors)

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:456-463
        // Cell's world-space min corner (bottom-left in your grid)
        //float xMin = room.bounds.xMin + (cellXY.x - room.bounds.xMin) * cellSize;
        //float zMin = room.bounds.yMin + (cellXY.y - room.bounds.yMin) * cellSize;
        // If you store absolute tile coords (not relative to bounds), use:
        //float xMin = (startWorld.x % 1f) * cellSize;
        //float zMin = (startWorld.y % 1f) * cellSize;
        //CleanupFloat(ref xMin, true);
        //CleanupFloat(ref zMin, true);

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:469-471
        // Offset amount in (u,v) units for radius: move by radius along the line normal.
        // For u+v=k or u-v=k, the unit normal length in (u,v) space is sqrt(2),
        // so c shifts by (playerRadius / cellSize) * sqrt(2).

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:496-499
        // Ray/line intersection in WORLD units.
        // Let u = (x - xMin)/s, v = (z - zMin)/s.
        // Solve a*u + b*v = c for T where x = x0 + dir.x*T, z = z0 + dir.z*T.
        //Vector2 xz0 = new Vector2(startWorld.x, startWorld.z);    // world coords of start

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Pathfinding.cs:564-567
            // Diagonal steps (dx != 0 && dy != 0) will trigger both checks above,
            // which correctly handles corner pinches. If you want stricter corner
            // blocking (no "corner cutting"), keep as-is. If you prefer permissive
            // behavior, only block if BOTH orthogonal edges are walls without doors.

---
