using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections;
using System;
using Unity.Mathematics;
using UnityEngine.SceneManagement;


/* DONE list...
-- DONE; Round world including fast oval room bounds checking
-- DONE: Nested Perlin / Stacked Perlin
-- DONE: Filter small wall areas
-- DONE: 3D walls
-- DONE: Code cleanup for organization and optimization
-- DONE: Use Rooms list to draw 3D, not a copy of the 2D map.
   (allows corridors above/below rooms)
-- DONE: Clamp ramp slopes at 1.
-- DONE: Don't draw diagonals when 3 walls on one tile.
-- DONE: Smart hash calculations
-- DONE: Don't show build progress option implementation
-- DONE: Reorganize files
-- DONE: Use more intelligent yielding to accomplish more each refresh.
-- DONE: Multi-layer map generation
-- DONE: Gently sloping floors without stairs (perlin heights)
-- DONE: Change long 3D routines to coroutines.
-- DONE: Presets of interesting dungeons - menu or random selection
-- DONE: Fix corridors between stacked rooms

   TODO list...
-- Simplex Noise
-- Adding extra corridors to break up tree
-- More tile types: stairs, doors, traps (with properties)
-- Fix early regeneration button (abort in-progress)
-- Fix pulldown after recompile
-- Enforce minimum width room connectivity
-- Walkthrough capability
-- Camera flight controls
-- Ceiling height minimum and room merging

-- Hex tiles
-- Remove dead code
-- Multiple passes of room generation layers
-- Doors
 */

// Master Dungeon Generation Class...
public partial class DungeonGenerator : MonoBehaviour
{
    [Header("Directory Object")]
    public ObjectDirectory dir;

    // Reference to external classes is maintained here
    public DungeonSettings cfg;     // This is used lots of places!

    public bool buildComplete = false;
    public Time lastScentTime;

    void OnEnable()  => Debug.Log($"[DG] OnEnable in scene '{gameObject.scene.name}' (id {GetInstanceID()})");
    void OnDisable() => Debug.Log($"[DG] OnDisable in scene '{gameObject.scene.name}' (id {GetInstanceID()})");
    //void OnDestroy() => Debug.LogWarning($"[DG] OnDestroy in scene '{gameObject.scene.name}' (id {GetInstanceID()})");

    void Awake()
    {
        //InitializeConnections();
        //SceneManager.sceneLoaded += OnSceneLoaded;
        Awake_Tilemap();
    }

    void OnDestroy()
    {
        Debug.LogWarning($"[DG] OnDestroy in scene '{gameObject.scene.name}' (id {GetInstanceID()})");
        SceneManager.sceneLoaded -= OnSceneLoaded;
        OnDestroy_Tilemap();
    }

    void OnSceneLoaded(Scene s, LoadSceneMode m)
    {
        //InitializeConnections();   // rebind after scene changes
    }

    void InitializeConnections()
    {
        if (!dir)
        {
            dir = FindFirstObjectByType<ObjectDirectory>(FindObjectsInactive.Include);
            if (!dir) Debug.LogError($"[DungeonGenerator.InitializeConnections] dir not found!");
        }

        // --- DungeonSettings (ScriptableObject) ---
        if (!cfg)
        {
            cfg = dir.cfg;
            if (!cfg) Debug.LogError($"[DungeonGenerator.InitializeConnections] cfg not valid from dir!");
        }
    }
    
    // ------------------------------------- //
    // Start is called by Unity before the first frame update
    public void Start()
    {
        // Initialize randomizer either with preselected seed, or one generated by clock
        if (cfg.randomizeSeed) cfg.seed = (int)DateTime.Now.Ticks;
        UnityEngine.Random.InitState(cfg.seed);
        Debug.Log("DungeonGenerator starting with seed: " + cfg.seed);

        // DOING THIS HANGS/CRASHES UNITY!!!!!!
        //StopAllCoroutines();
        //dir.dungeonBuildSettingsUI.LoadMapSettingsByName("01_House_Tutorial");


        // Start the fun...

        StartCoroutine(RegenerateDungeon(null));
        StartCoroutine(ScentDecayOnIntervals());

        EnableSplash();
    }

    // Enables the Splash screen in front of DungeonGenerator so start menu hides building process.
    public static void EnableSplash()
    {
        Scene scene = SceneManager.GetActiveScene();
        GameObject[] roots = scene.GetRootGameObjects();

        foreach (var go in roots)
        {
            if (go.name == "Splash")
            {
                Debug.Log("Enabling Splash while DungeonGenerator running in background.");
                go.SetActive(true);
                return;
            }
        }
        Debug.LogWarning("Did not find object Splash to enable Splash Screen in DungeonGenerator.");
        return; // didn't find it.
    }

    // RegenerateDungeon is the main coroutine that handles dungeon generation.
    // It orchestrates the various steps involved in creating the dungeon layout.
    // Step 0: Select settings
    // Step 1: Initialize the dungeon
    // Step 2: Place rooms (ScatterRooms or CellularAutomata)
    // Step 3: Convert rooms to a list of floor tiles (ConvertRectToRoomPoints or findRoomTiles for CA)
    // Step 4: Combine overlapping rooms (MergeOverlappingRooms)
    // Step 5: Connect rooms by corridors (DrawCorridors)

    // Other routines:
    //  Draw Map by Rooms
    //  Draw Walls

    public IEnumerator RegenerateDungeon(TimeTask tm = null)
    {
        buildComplete = false;
        bool local_tm = false;
        if (tm == null) { tm = TimeManager.Instance.BeginTask("RegenerateDungeon"); local_tm = true; }
        try
        {
            yield return null;  // give time for all allocations to complete
            room_rects = new List<RectInt>(); // Clear the list of room rectangles
            map = new byte[cfg.mapWidth, cfg.mapHeight];
            mapHeights = new int[cfg.mapWidth, cfg.mapHeight];
            Destroy3D();
            hf = null; // clear heightfield
            if (tm.IfYield()) yield return null;     // cooperative yield decision

            BottomBanner.Show("Generating dungeon...");

            // Step 0: Select settings
            switch (cfg.RoomAlgorithm) // Change this to select different algorithms
            {
                case DungeonSettings.RoomAlgorithm_e.Scatter_Overlap:
                    cfg.generateOverlappingRooms = true;
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = true;
                    //tavern.enabled = false;
                    cfg.usePackedRooms = false;
                    cfg.useDiagonalCorners = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.Scatter_NoOverlap:
                    cfg.generateOverlappingRooms = false;
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = true;
                    //tavern.enabled = false;
                    cfg.usePackedRooms = false;
                    cfg.useDiagonalCorners = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.CellularAutomata:
                    cfg.generateOverlappingRooms = false;
                    cfg.useCellularAutomata = true;
                    cfg.useScatterRooms = false;
                    cfg.usePerlin = false; // Disable Perlin for CA
                    //tavern.enabled = false;
                    cfg.usePackedRooms = false;
                    cfg.useDiagonalCorners = true;
                    break;
                case DungeonSettings.RoomAlgorithm_e.CellularAutomataPerlin:
                    cfg.generateOverlappingRooms = false;
                    cfg.useCellularAutomata = true;
                    cfg.useScatterRooms = false;
                    cfg.usePerlin = true; // Enable Perlin for CA
                    //tavern.enabled = false;
                    cfg.usePackedRooms = false;
                    cfg.useDiagonalCorners = true;
                    break;
                case DungeonSettings.RoomAlgorithm_e.Tavern:
                    cfg.generateOverlappingRooms = false;
                    //tavern.enabled = true;
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = false;
                    cfg.usePackedRooms = false;
                    cfg.useDiagonalCorners = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.PackedRooms:
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = false;
                    cfg.usePackedRooms = true;
                    cfg.useDiagonalCorners = false;  /// Allow diagonals for packed rooms
                    break;
            }

            BottomBanner.Show("Initialize dungeon...");


            // ===== Step 1. Initialize the dungeon
            tilemap.ClearAllTiles();
            tilemap_walls.ClearAllTiles();
            tilemap_doors.ClearAllTiles();
            rooms.Clear();
            map = new byte[cfg.mapWidth, cfg.mapHeight];
            FillVoidToWalls(map);
            yield return tm.YieldOrDelay(cfg.stepDelay);

            // ===== Step 2. Place rooms

            // TAVERN
            //            if (tavern.enabled)
            //            {
            //                yield return StartCoroutine(BuildTavern(tm: null));
            //            }

            if (cfg.usePackedRooms)
            {
                yield return StartCoroutine(GeneratePackedRooms());
            }
            if (cfg.useCellularAutomata) // Cellular Automata generation
            {
                BottomBanner.Show("Cellular Automata cavern generation iterating...");
                yield return StartCoroutine(RunCellularAutomation(tm: null));
                DrawWalls();
            }
            if (cfg.useScatterRooms)
            {
                BottomBanner.Show("Scattering rooms...");
                yield return StartCoroutine(ScatterRooms(tm: null));
                Debug.Log("ScatterRooms done, room_rects.Count = " + room_rects.Count);
                //DrawMapByRects(room_rects, room_rects_color);
                //DrawWalls();
            }

            yield return tm.YieldOrDelay(cfg.stepDelay);

            // Step 3: Combine overlapping rooms
            BottomBanner.Show("Locate Discrete rooms...");
            if (cfg.useCellularAutomata) // locate rooms from cellular automata
            {
                BottomBanner.Show("Remove tiny rocks...");
                yield return StartCoroutine(RemoveTinyRocksCoroutine(tm: null));

                // For Cellular Automata, find rooms from the map
                BottomBanner.Show("Locate Discrete rooms...");
                yield return StartCoroutine(FindClustersCoroutine(map, FLOOR, rooms, tm: null));

                BottomBanner.Show("Remove tiny rooms...");
                yield return StartCoroutine(RemoveTinyRoomsCoroutine(tm: null));
            }
            if (cfg.useScatterRooms)
            {
                BottomBanner.Show("Convert all Rects to Rooms...");
                rooms = ConvertAllRectToRooms(room_rects, room_rects_color, SetTile: true);
                DrawMapByRooms(rooms);
                DrawWalls();
                if (tm.IfYield()) yield return null;     // cooperative yield decision

                yield return tm.YieldOrDelay(cfg.stepDelay);
                // Step 4: Merge overlapping rooms
                BottomBanner.Show("Merging Overlapping Rooms...");
                if (cfg.MergeScatteredRooms)
                    rooms = MergeOverlappingRooms(rooms, considerAdjacency: true, eightWay: false);
                DrawMapByRooms(rooms);
                DrawWalls();
                yield return tm.YieldOrDelay(cfg.stepDelay); // depends on cfg.showBuildProcess
            }

            if (cfg.useCellularAutomata || cfg.useScatterRooms || cfg.usePackedRooms)
            {
                // Optionally add Perlin noise to floor heights
                perlinSeedX = cfg.GlobalPerlinSeed ? UnityEngine.Random.Range(0f, 9999f) : 0f;
                perlinSeedY = cfg.GlobalPerlinSeed ? UnityEngine.Random.Range(0f, 9999f) : 0f;

                if (cfg.perlinFloorHeights > 0)
                {
                    for (int r = 0; r < rooms.Count; r++)
                    {
                        rooms[r] = AddPerlinToFloorHeights(rooms[r]);
                    }
                }

                // Optionally slope entire rooms in a random direction
                if (cfg.slopeRoomMaxAngle > 0)
                {
                    for (int r = 0; r < rooms.Count; r++)
                    {
                        Vector2 topDir = new Vector2(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized;
                        //Debug.Log("Sloping room " + r + " in direction " + topDir + " with max angle " + cfg.slopeRoomMaxAngle);
                        rooms[r] = TiltRoom(rooms[r], topDir, cfg.slopeRoomMaxAngle, heightUnitsPerTile: cfg.unitHeight);
                    }
                }

                // ======== End Rooms, Begin Corridors ========
                if (cfg.useCellularAutomata || cfg.useScatterRooms)
                {
                    DrawMapByRooms(rooms);
                    DrawWalls();

                    // Step 5: Connect rooms with corridors
                    BottomBanner.Show("Connecting Rooms with Corridors...");
                    yield return StartCoroutine(ConnectRoomsByCorridors(tm: null));

                    DrawMapByRooms(rooms);
                    DrawWalls();
                    yield return tm.YieldOrDelay(cfg.stepDelay);
                }
            }

            BottomBanner.Show("Building Wall Lists...");
            yield return null;
            DrawMapByRooms(rooms);  // update the 2D map before finishing.
            DrawWalls();

            yield return StartCoroutine(BuildWallsAroundFloorsInRooms(tm: null));
            DrawMapByRooms(rooms);  // update the 2D map before finishing.
            DrawWalls();

            // Optionally tilt individual floor tiles
            if (cfg.enableTiltedTiles && cfg.tiltFloorTilesMaxAngle != 0)  // If > 0, tilt individual floor tiles by up to this angle in degrees.
            {
                BottomBanner.Show("Calculating Floor Tilts...");
                yield return new WaitForSeconds(.2f);
                // Build the heightfield hf if it doesn't exist yet
                //if (hf == null) PrepareHeightfield();
                yield return StartCoroutine(TiltAllFloors(tm: null));
            }

            BottomBanner.Show("Height Map Build...");
            yield return null;
            // FillVoidToWalls(map);
            DrawMapByRooms(rooms);  // update the 2D map before finishing.
            DrawWalls();
            yield return StartCoroutine(Build3DFromRooms(tm: null));
            // If Build should be static, change its definition to 'public static void Build(...)' in HeightMap3DBuilder.

            DrawMapByRooms(rooms);  // update the 2D map before finishing.
            DrawWalls();

            UpdateCellGridFromRooms(rooms);  // update the master cellGrid from the rooms list
            // Build the heightfield hf if it doesn't exist yet
            if (hf == null) PrepareHeightfield();

            BottomBanner.ShowFor("Dungeon generation complete!", 5f);
            buildComplete = true;

            yield return StartCoroutine(dir.player.DetermineStartPosition());
        }
        finally { if (local_tm) tm.End(); }
        TimeManager.Instance.DumpStats();
    }

    // ------------ Floor tile tilting functions ------------
    public IEnumerator TiltAllFloors(TimeTask tm = null)
    {
        bool local_tm = false;
        if (tm == null) { tm = TimeManager.Instance.BeginTask("TiltAllFloors"); local_tm = true; }
        try
        {
            if (hf == null) yield break;
            if (rooms == null) yield break;


            // Validate config once
            float tileSizeX = Mathf.Max(1e-4f, 1f);           // <- replace 1f if you use different tile size
            float tileSizeZ = Mathf.Max(1e-4f, 1f);
            float heightUnit = Mathf.Max(1e-6f, cfg.unitHeight);
            float maxAngle = Mathf.Clamp(cfg.tiltFloorTilesMaxAngle, 0f, 85f);
            int threshold = Mathf.Max(0, 100);  // make sure you have this int version

            int yieldCounter = 0;


            foreach (var room in rooms)
            {
                if (room?.cells == null) continue;

                foreach (var cell in room.cells)
                {
                    try
                    {
                        // Use the same height unit for sampling & tilt
                        int heightCenter = cell.z;

                        // Safe neighbor sampling: return null if no neighbor within threshold
                        int? hN = TrySampleNeighborHeight(cell.x, cell.y + 1, heightCenter, threshold, out var zn) ? (zn) : (int?)null;
                        int? hE = TrySampleNeighborHeight(cell.x + 1, cell.y, heightCenter, threshold, out var ze) ? (ze) : (int?)null;
                        int? hS = TrySampleNeighborHeight(cell.x, cell.y - 1, heightCenter, threshold, out var zs) ? (zs) : (int?)null;
                        int? hW = TrySampleNeighborHeight(cell.x - 1, cell.y, heightCenter, threshold, out var zw) ? (zw) : (int?)null;

                        // Compute rotation (handles missing neighbors + edge softening)
                        Quaternion rot = ComputeTiltTile(
                            hCenter: heightCenter,
                            hNorth: hN, hEast: hE, hSouth: hS, hWest: hW,
                            tileSizeX: tileSizeX, tileSizeZ: tileSizeZ,
                            heightUnit: heightUnit,
                            baseYawDeg: 180f,
                            maxAbsAngleDeg: maxAngle,
                            edgeTiltScale: cfg.edgeTiltScale
                        );

                        // Guard against NaN/Inf (Unity can crash if these hit transforms)
                        if (IsBadRotation(rot))
                        {
                            rot = Quaternion.identity; // fallback
                        }

                        // Cache it on your cell (adjust field names/types as needed)
                        cell.tiltFloor = rot;
                    }
                    catch (Exception ex)
                    {
                        // Keep going; log once per problematic cell
                        Debug.LogWarning($"TiltAllFloors: exception at cell ({cell.x},{cell.y}) h={cell.height}: {ex.Message}");
                        cell.tiltFloor = Quaternion.identity;
                    }

                    // Cooperative yield
                    if ((yieldCounter++ & 0xFF) == 0) // every 256 cells
                    {
                        if (tm.IfYield()) yield return null;
                    }
                }

                if (tm.IfYield()) yield return null;
            }
        }
        finally
        {
            if (local_tm && tm != null) tm.End();
        }
    }

    // ------------ Data validity checkers for above function ------------

    private bool TrySampleNeighborHeight(int x, int y, int zCenter, int threshold, out int zNeighbor)
    {
        zNeighbor = 0;
        if (x < 0 || y < 0 || x >= hf.Width || y >= hf.Height) return false;

        // Use heightCenter (zCenter) so units match your heightfield
        if (!hf.TryQueryAt(x, y, zCenter, threshold, out var match))
            return false;

        zNeighbor = match.z;
        return true;
    }

    private static bool IsBadRotation(Quaternion q)
    {
        // Reject NaN or Inf
        return float.IsNaN(q.x) || float.IsNaN(q.y) || float.IsNaN(q.z) || float.IsNaN(q.w) ||
            float.IsInfinity(q.x) || float.IsInfinity(q.y) || float.IsInfinity(q.z) || float.IsInfinity(q.w) ||
            (q.x == 0f && q.y == 0f && q.z == 0f && q.w == 0f); // invalid quaternion
    }


    // Rooms list -> 2D tilemap
    public void DrawMapByRooms(List<Room> rooms, bool clearscreen = true)
    {
        Vector3Int center_pos;

        Vector3Int floor_pos;                   // position one tile away in the direction of the wall/door
        Vector3 floor_offset;             // offset to side of tile closest to wall/door
        Vector3 floor_rotation;  // determined by tile rotation: rotate vertical to lay flat.
        Vector3 floor_scale;  

        Vector3Int wall_pos;                   // position one tile away in the direction of the wall/door
        Vector3 wall_offset;             // offset to side of tile closest to wall/door
        Vector3 wall_rotation;  // determined by tile rotation: rotate vertical to lay flat.
        Vector3 wall_scale;  

        Vector3Int door_pos;                   // position one tile away in the direction of the wall/door
        Vector3 door_offset;             // offset to side of tile closest to wall/door
        Vector3 door_rotation;  // determined by tile rotation: rotate vertical to lay flat.
        Vector3 door_scale;  

        //Debug.Log("Drawing Map by " + rooms.Count + " rooms...");
        if (clearscreen)
        {
            tilemap.ClearAllTiles();    // floors
            tilemap_doors.ClearAllTiles();
            tilemap_walls.ClearAllTiles();
        }
        if (map == null) map = new byte[cfg.mapWidth, cfg.mapHeight];
        if (mapHeights == null) mapHeights = new int[cfg.mapWidth, cfg.mapHeight];

        foreach (var room in rooms)
        {
            //bool printonce = true;
            // CELL_VERSION
            //Debug.Log("DrawMapByRooms: room " + room.my_room_number + " size: " + room.cells.Count);
            
            foreach (var cell in room.cells)
            {
                //Debug.Log($"x,y = {cell.x},{cell.y} : cell.walls = {cell.walls}, cell.doors = {cell.doors}");

                Vector3Int pos3 = new(cell.x,cell.y,0);
                Vector3Int center_pos3 = new();
                Vector3Int d = new();

                // update the maps
                map[cell.x, cell.y] = FLOOR;
                mapHeights[cell.x, cell.y] = cell.height;

                // --------------- floors
                // calculate everything necessary to transform and draw the WALL
                floor_pos = new Vector3Int(pos3.x, pos3.y, 0);                 // position one tile away in the direction of the wall/door
                floor_offset = new Vector3(0,0,0);             // offset to side of tile closest to wall/door
                floor_rotation = new Vector3(90f, 0f, 0f);  // determined by tile rotation: rotate vertical to lay flat.
                floor_scale = new Vector3(1f,1f,1f);              // scale to half x,y size

                SetTilemapWithTransforms(tilemap: tilemap,
                                            pos: floor_pos,
                                            offset: floor_offset,
                                            rotation: floor_rotation,
                                            scale: floor_scale,
                                            tile: floorTile,
                                            color: room.colorFloor);

                // --------------- walls
                // tileMap_walls is scaled down by 3 each direction.  To match floors, multiply by 3.
                // center_pos3 is the middle cell corresponding to the larger floor cell.
                // We then add 1 to the appropriate direction to get the edge cells closest to the wall/door.
                center_pos = new Vector3Int(cell.x * 3 + 1, cell.y * 3 + 1, 0);
                int rotate = 0;
                for (int i = 0; i < 4; i++) // do all 4 directions
                {
                    switch (i)
                    {
                        case 0:
                            if (cell.walls.HasFlag(DirFlags.N))
                            {
                                d = Vector3Int.up;
                                rotate = 0;
                            }
                            else continue;
                            break;
                        case 1:
                            if (cell.walls.HasFlag(DirFlags.S))
                            {
                                d = Vector3Int.down;
                                rotate = 0;
                            }
                            else continue;
                            break;
                        case 2:
                            if (cell.walls.HasFlag(DirFlags.W))
                            {
                                d = Vector3Int.left;
                                rotate = 90;
                            }
                            else continue;
                            break;
                        case 3:
                            if (cell.walls.HasFlag(DirFlags.E))
                            {
                                d = Vector3Int.right;
                                rotate = 90;
                            }
                            else continue;
                            break;
                        default:    // should never happen
                            continue;
                    }
                    // calculate everything necessary to transform and draw the WALL
                    wall_pos = center_pos + d;                 // position one tile away in the direction of the wall/door
                    wall_offset = (Vector3)d;// / 2f;             // offset to side of tile closest to wall/door
                    //wall_offset = new Vector3(0f, 0f, 0f); //DEBUG
                    wall_rotation = new Vector3(90f, rotate, 0f);  // determined by tile rotation: rotate vertical to lay flat.
                    wall_scale = new Vector3(3f, 0.1f, 0f);  // scale to half x,y size
                      //wall_scale.z = 1;                        // leave z scale 1

                    SetTilemapWithTransforms(tilemap: tilemap_walls,
                                             pos: wall_pos,
                                             offset: wall_offset,
                                             rotation: wall_rotation,
                                             scale: wall_scale,
                                             tile: wallTile,
                                             color: Color.black);
 
                }

                // --------------- doors
                // tileMap_doors is scaled down by 3 each direction.  To match floors, multiply by 3.
                // center_pos3 is the middle cell corresponding to the larger floor cell.
                // We then add 1 to the appropriate direction to get the edge cells closest to the wall/door.
                center_pos3 = new Vector3Int(pos3.x * 3 + 1, pos3.y * 3 + 1, 0);

                for (int dir_index = 0; dir_index < 4; dir_index++)
                {
                    switch (dir_index)
                    {
                        case 0:
                            if (cell.doors.HasFlag(DirFlags.N))
                            {
                                d = Vector3Int.up;
                                rotate = 0;
                            }
                            else continue;
                            break;
                        case 1:
                            if (cell.doors.HasFlag(DirFlags.S))
                            {
                                d = Vector3Int.down;
                                rotate = 0;
                            }
                            else continue;
                            break;
                        case 2:
                            if (cell.doors.HasFlag(DirFlags.W))
                            {
                                d = Vector3Int.left;
                                rotate = 90;
                            }
                            else continue;
                            break;
                        case 3:
                            if (cell.doors.HasFlag(DirFlags.E))
                            {
                                d = Vector3Int.right;
                                rotate = 90;
                            }
                            else continue;
                            break;
                        default:    // should never happen
                            continue;
                    }
                    // calculate everything necessary to transform and draw the DOOR
                    door_pos = center_pos + d;                 // position one tile away in the direction of the wall/door
                    door_offset = (Vector3)d / 2f;             // offset to side of tile closest to wall/door
                    door_offset = new Vector3(0f, 0f, 0f); //DEBUG
                    door_rotation = new Vector3(90f, rotate, 0f);  // determined by tile rotation: rotate vertical to lay flat.
                    door_scale = (Vector3)d / 2f;              // scale to half x,y size
                      door_scale.z = 1;                        // leave z scale 1
                    door_scale = new Vector3(1f, 1f, 0.01f); //DEBUG
                    SetTilemapWithTransforms(tilemap: tilemap_doors,
                                             pos: door_pos,
                                             offset: door_offset,
                                             rotation: door_rotation,
                                             scale: door_scale,
                                             tile: floorTile,
                                             color: Color.red);
 
                }
            }
        }
    }

    // NEW    
    public void SetTilemapWithTransforms(Tilemap tilemap, Vector3Int pos, Vector3 offset, Vector3 rotation, Vector3 scale, TileBase tile, Color color)
    {

        Matrix4x4 transform_m = Matrix4x4.TRS(                   // combine the last 3 to one transformation operation
            offset,                  // offset
            Quaternion.Euler(rotation),   // rotation of tile to lie flat on ground
            scale           // scale
            );

        tilemap.SetTile(pos, tile);
        tilemap.SetTileFlags(pos, TileFlags.None); // Allow color changes
        tilemap.SetColor(pos, color); // Set room color
        tilemap.SetTransformMatrix(pos, transform_m);  // nudges the sprite within its cell

        
        //Debug.Log("SetTilemapWithTransforms");
        //Debug.Log($"pos     ={pos.ToString()}");
        //Debug.Log($"scale   ={scale.ToString()}");
        //Debug.Log($"offset  ={offset.ToString()}");
        //Debug.Log($"rotation={rotation.ToString()}");
    }

    // New
    public Room DrawCorridorSloped(Vector2Int start, Vector2Int end, int start_height, int end_height, int start_room, int end_room)
    {
        List<Vector2Int> path;
        HashSet<Vector2Int> hashPath = new();
        HashSet<Vector2Int> neighbor_start_hashPath = new();
        HashSet<Vector2Int> neighbor_end_hashPath = new();
        Room room = new();

        switch (cfg.TunnelsAlgorithm)
        {
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsOrthogonal:
                BottomBanner.Show("Drawing orthogonal ..");
                path = OrthogonalLine(start, end);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsStraight:
                BottomBanner.Show("Drawing straight ..");
                path = BresenhamLine(start, end);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsOrganic:
                BottomBanner.Show("Drawing organic ..");
                path = OrganicLine(start, end);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsCurved:
                BottomBanner.Show("Drawing curved ..");
                path = BezierLine(start, end);
                break;
            default:
                BottomBanner.Show("Drawing Noisy Bresenham ..");
                path = NoisyBresenhamLine(start, end);
                break;
        }

        int path_length = path.Count;
        if (path_length <= 1)
        {
            //Debug.Log($"path_length = {path_length}, must be > 1");
            //TODO: make a vertical ladder?
            return (room); // empty room
        }
        float delta_h = (float)(end_height - start_height) / (float)(path_length - 1);
        // pre-seed the hashPath with both end rooms so we don't add corridor tiles there.

        foreach (Cell cell in rooms[start_room].cells)
            neighbor_start_hashPath.Add(cell.pos);
        foreach (Cell cell in rooms[end_room].cells)
            neighbor_end_hashPath.Add(cell.pos);

        if (cfg.limit_slope && (Math.Abs(delta_h) > 1f))
        {
            Debug.Log($"Slope of corridor is too great Abs({delta_h}) > 1");
            delta_h = Math.Clamp(delta_h, -1f, 1f); // Don't allow ramps too steep to climb.
            // Should we generate a new corridor that is longer? TODO
        }

        //Debug.Log("Drawing corridor length " + path.Count + " from " + start + " to " + end + " width " + cfg.corridorWidth + " using " + cfg.TunnelsAlgorithm);
        //Debug.Log("Corridor: start_height=" + start_height + " end_height=" + end_height + " length=" + path_length);
        int brush_neg = -cfg.corridorWidth / 2;
        int brush_pos = brush_neg + cfg.corridorWidth;

        //foreach (Vector2Int point in path)
        for (int i = 0; i < path.Count; i++)
        {
            Vector2Int point = path[i];
            int height = start_height + (int)Math.Round(i * delta_h);
            // Square brush around each line point
            for (int dx = brush_neg; dx < brush_pos; dx++)
            {
                for (int dy = brush_neg; dy < brush_pos; dy++)
                {
                    // At both endpoints, only use centerpoint of brush.
                    // Going beyond this can make odd transitions.
                    if ((i == 0 || i == path.Count - 1) && ((dx != 0) || (dy != 0)))
                        continue;

                    Vector3Int tilePos3d = new Vector3Int(point.x + dx, point.y + dy, 0);
                    if (tilePos3d.x < 0 || tilePos3d.x >= cfg.mapWidth || tilePos3d.y < 0 || tilePos3d.y >= cfg.mapHeight)
                    {
                        continue; // Skip out-of-bounds tiles
                    }
                    tilemap.SetTile(tilePos3d, floorTile);

                    Vector2Int tilePos2 = new Vector2Int(tilePos3d.x, tilePos3d.y);

                    // Keep highest point
                    //bool overlap = false;
                    int neighborheight;
                    height = CalculateRampHeightFromPosition(tilePos2, start, end, start_height, end_height);

                    if (!hashPath.Contains(tilePos2))
                    {
                        // check if neighbor overlap.  If so, remove from neighbor.
                        if (neighbor_start_hashPath.Contains(tilePos2))
                        {
                            //overlap = true;
                            neighborheight = rooms[start_room].GetHeightInRoom(tilePos2);
                            if (((neighborheight - height) > 0) && ((neighborheight - height) < 30))
                            {
                                // punch hole in ceiling of start_room
                                int cell_num = rooms[start_room].GetCellInRoom(tilePos2);
                                rooms[start_room].cells.RemoveAt(cell_num);
                                rooms[start_room].ResetCellDictionary();
                            }
                        }
                        if (neighbor_end_hashPath.Contains(tilePos2))
                        {
                            //overlap = true;
                            neighborheight = rooms[end_room].GetHeightInRoom(tilePos2);
                            if (((neighborheight - height) > 0) && ((neighborheight - height) < 30))
                            {
                                // punch hole in ceiling of end_room
                                int cell_num = rooms[end_room].GetCellInRoom(tilePos2);
                                rooms[end_room].cells.RemoveAt(cell_num);
                                rooms[end_room].ResetCellDictionary();
                            }
                        }
                    }
                    // Add the corridor cell
                    room.cells.Add(new Cell(tilePos2.x, tilePos2.y, height));
                }
            }
        }
        room.isCorridor = true;
        return room;
    }

    // based on distances from both ends, calculate height.
    // problem: past the ends, height goes down.  TODO: better algorithm.
    int CalculateRampHeightFromPosition(Vector2Int target, Vector2Int start, Vector2Int end, int start_height, int end_height)
    {
        float target_to_start;
        float target_to_end;
        float pct_distance;

        Vector2Int delta;
        float target_height;

        delta = (target - start);
        target_to_start = (float)Math.Sqrt(delta.sqrMagnitude);
        delta = (target - end);
        target_to_end = (float)Math.Sqrt(delta.sqrMagnitude);
        pct_distance = target_to_start / (target_to_start + target_to_end);

        target_height = (end_height - start_height) * pct_distance + start_height;
        return (int)Math.Round(target_height);
    }

    // DrawWalls() will add solid wall tiles around all rooms on the tilemap.
    // It is intended for non-thinWalls maps
    public void DrawWalls()  // from tilemap, adds walls to the existing 2D tilemap
    {
        return; // DEBUG: This isn't working quite right, remove for now...
/*        BoundsInt bounds = tilemap.cellBounds;
        //BottomBanner.Show("Drawing walls...");
        for (int x = bounds.xMin - 1; x <= bounds.xMax + 1; x++)
        {
            for (int y = bounds.yMin - 1; y <= bounds.yMax + 1; y++)
            {
                Vector3Int pos = new(x, y, 0);
                if (tilemap.GetTile(pos) == floorTile)
                    continue;                       // Skip floor tiles
                if (HasFloorNeighbor(pos))
                    tilemap.SetTile(pos, wallTile); // add wall tile
                else
                    tilemap.SetTile(pos, null);     // Remove wall if no floor neighbor
            }
        }
*/
    }

    // UNUSED
    // Check if a tile at position pos has a neighboring floor tile within the specified radius
    bool HasFloorNeighbor(Vector3Int pos, int radius = 1)
    {
        if (tilemap == null || floorTile == null) return false; // Safety check

        // Check all neighbors within the specified radius
        NeighborCache.Shape shape = cfg.neighborShape;
        bool includeDiagonals = cfg.includeDiagonals;
        var neighbors = NeighborCache.Get(radius, shape, borderOnly: true, includeDiagonals);

        foreach (var offset in neighbors)
        {
            Vector3Int neighborPos = pos + offset;
            if (tilemap.GetTile(neighborPos) == floorTile)
            {
                return true; // Found a floor tile neighbor
            }
        }
        return false; // No floor tile neighbors found
    }


    // point bounds checking for rectangular or oval world maps
    public bool IsPointInWorld(Vector2Int point)
    {
        if (point.x < 0 || point.y < 0 ||
            point.x > cfg.mapWidth || point.y > cfg.mapHeight)
            return false; // out of the world
        if (!cfg.roundWorld) return true; // square world, limits are sufficient

        // Round world (axis-aligned ellipse) inscribed in the map.
        Vector2 Cw = new Vector2(cfg.mapWidth * 0.5f, cfg.mapHeight * 0.5f);
        float margin = 0.5f; // hardcoded
        float Rx = cfg.mapWidth * 0.5f - margin;
        float Ry = cfg.mapHeight * 0.5f - margin;
        float Rx2 = Rx * Rx, Ry2 = Ry * Ry;
        float dx = point.x - Cw.x, dy = point.y - Cw.y;
        return ((dx * dx) / Rx2 + (dy * dy) / Ry2) <= 1f; // <= 1 means inside world ellipse
    }


    // UNUSED
    void GenerateWallLists_OLD() // replaced by BuildWallsAroundFloorsInRooms in Rooms.cs
    {
        //List<Vector2Int> wall_list_room;
        //HashSet<Vector2Int> new_wall_hash;

        // TODO: replace with directions in Room.cs
        Vector2Int[] directions = {
            Vector2Int.up, Vector2Int.down,
            Vector2Int.left, Vector2Int.right
        };

        for (int room_number = 0; room_number < rooms.Count; room_number++)
        {
            //wall_list_room = new();
            //new_wall_hash = new();
            foreach (Cell cell in rooms[room_number].cells)
            {
                Vector2Int pos = cell.pos;
                foreach (Vector2Int dir in directions)
                {
                    // look in dir, if not in room then consider it a wall and
                    ///  set appropriate wall direction flag.
                    if (rooms[room_number].GetCellInRoom(pos + dir) == -1) // non-existance check.
                    {
                        DirFlags dir_flag = DirFlagsEx.FromVector2Int(dir);
                        cell.walls |= dir_flag;

                        // Debug to map display:
                        Vector3Int pos3d = cell.pos3d;
                        pos3d.z = 0;
                        tilemap.SetTile(pos3d, wallTile);
                        tilemap.SetTileFlags(pos3d, TileFlags.None);
                        tilemap.SetColor(pos3d, Color.red);
                        //Debug.Log($"Wall found in direction {dir.x},{dir.y}; flags + {dir_flag} = {cell.walls}");
                    }
                }
                //Debug.Log($"walls = {cell.walls}");
            }
        }
    }

    // uses map[,]
    public void FillVoidToWalls(byte[,] map)
    {
        for (var y = 0; y < cfg.mapHeight; y++)
            for (var x = 0; x < cfg.mapWidth; x++)
            {
                if (map[x, y] == 0) map[x, y] = WALL;
            }
    }

    // NEW
    /// <summary>
    /// Merge rooms that overlap (share at least one tile).
    /// If considerAdjacency is true, rooms that touch by edge/corner are merged too.
    /// </summary>
    /// <param name="rooms">Input rooms (each has List<Vector2Int> tiles)</param>
    /// <param name="considerAdjacency">If true, merge when tiles are neighbors (4- or 8-connected)</param>
    /// <param name="eightWay">If adjacency is considered, choose 4-way or 8-way</param>
    public static List<Room> MergeOverlappingRooms(List<Room> rooms, bool considerAdjacency = false, bool eightWay = true)
    {
        //BottomBanner.Show("Merging overlapping rooms...");
        if (rooms == null || rooms.Count == 0) return new List<Room>();

        var dsu = new DSU(rooms.Count);
        var owner = new Dictionary<Vector2Int, int>(1024);

        // Optional neighbor offsets for adjacency merging
        Vector2Int[] n4 = new[]
        {
            new Vector2Int( 1, 0),
            new Vector2Int(-1, 0),
            new Vector2Int( 0, 1),
            new Vector2Int( 0,-1)
        };
        Vector2Int[] n8 = new[]
        {
            new Vector2Int( 1, 0), new Vector2Int(-1, 0), new Vector2Int(0, 1), new Vector2Int(0,-1),
            new Vector2Int( 1, 1), new Vector2Int( 1,-1), new Vector2Int(-1, 1), new Vector2Int(-1,-1)
        };
        var neighbors = eightWay ? n8 : n4;

        // 1) Scan all tiles, union rooms that share tiles (overlap)
        for (int i = 0; i < rooms.Count; i++)
        {
            var cells = rooms[i].cells;
            for (int k = 0; k < cells.Count; k++)
            {
                var t = cells[k].pos;

                if (!owner.TryGetValue(t, out int j))
                {
                    owner[t] = i; // first time we see this tile, claim it
                }
                else
                {
                    // tile already owned by room j => overlap with i
                    dsu.Union(i, j);
                }

                // 2) Optional: adjacency-based merging (touching rooms)
                if (considerAdjacency)
                {
                    foreach (var d in neighbors)
                    {
                        var n = t + d;
                        if (owner.TryGetValue(n, out int kOwner))
                            dsu.Union(i, kOwner);
                    }
                }
            }
        }

        // 3) Fold tiles into their root groups while PRESERVING order and height pairing
        var groupedTiles = new Dictionary<int, List<Vector2Int>>();
        var groupedHeights = new Dictionary<int, List<int>>();
        var groupedSeen = new Dictionary<int, HashSet<Vector2Int>>();

        for (int i = 0; i < rooms.Count; i++)
        {
            int root = dsu.Find(i);
            if (!groupedTiles.ContainsKey(root))
            {
                groupedTiles[root] = new List<Vector2Int>(rooms[i].cells.Count);
                groupedHeights[root] = new List<int>(rooms[i].cells.Count);
                groupedSeen[root] = new HashSet<Vector2Int>();
            }

            //var rTiles = rooms[i].GetTilesList();     // not a created function
            //var rHeights = rooms[i].GetHeightsList();
            var rCells = rooms[i].cells;

            for (int k = 0; k < rooms[i].cells.Count; k++)
            {
                var t = rCells[k].pos;
                var h = rCells[k].height;
                if (!groupedSeen[root].Add(t))
                    continue; // skip duplicates while preserving first-seen order

                groupedTiles[root].Add(t);
                groupedHeights[root].Add(h);
            }
        }

        // 4) Emit merged rooms with preserved tile/height order
        var merged = new List<Room>(groupedTiles.Count);
        foreach (var root in groupedTiles.Keys)
        {
            var newRoom = new Room(groupedTiles[root], groupedHeights[root]);
            newRoom.setColorFloor(highlight: true);
            merged.Add(newRoom);
        }

        // (Optional) sort by size descending like your existing code
        merged.Sort((a, b) => b.Size.CompareTo(a.Size));
        return merged;
    }

    public static bool Check(object o, string name, UnityEngine.Object ctx = null)
    {
        if (o == null)
        {
            Debug.LogError($"[Agent] Null reference: {name}", ctx);
            return false;
        }
        return true;
    }


    public IEnumerator ScentDecayOnIntervals()
    {
        var DecayWaiter = new WaitForSeconds(cfg.ScentInterval);
        while (true)
        {
            yield return DecayWaiter;
            StartCoroutine(ScentDecayAndSpread());
        }
    }

    // This routine is called every cfg.ScentInterval
    //   It scans every Cell in every Room looking for existing scents.
    //   It decays scent by cfg.ScentDecayRate.
    //   It spreads scent to each neighbor by cfg.ScentSpradAmount.
    //   All of these are put into a nextScent list so we only work on the originals.
    //     It moves all the nextScent list entries to the scent list except...
    //       It removes the scent if it decays below cfg.ScentMinimum
    public IEnumerator ScentDecayAndSpread()
    {
        Cell neighborCell;
        Vector2Int nPos;
        int spread_count;

        yield return null;
        if (!buildComplete) yield break;
        //yield return new WaitUntil(() => buildComplete);

        foreach (Room r in rooms)
        {
            foreach (Cell c in r.cells)
            {
                if (c.scents != null)
                {
                    for (int s = 0; s < c.scents.Count; s++)
                    {
                        float orig_intensity = c.scents[s].intensity;
                        spread_count = 0;

                        // spread scent to nearby cells
                        foreach (DirFlags dir in DirFlagsEx.AllCardinals)
                        {
                            //walls and closed doors block scent spread
                            if ((dir & (c.walls | (c.doors /* & c.doors_closed*/))) == 0)    // TODO: include door open/closed
                            {
                                nPos = DirFlagsEx.ToVector2Int(dir);
                                neighborCell = GetCellFromHf(c.x + nPos.x, c.y + nPos.y, c.z, threshold: 10);
                                if (neighborCell != null)
                                {
                                    // spread the scent...
                                    AddToNextScentIntensity(neighborCell, s, orig_intensity * cfg.ScentSpreadAmount);
                                    spread_count++;
                                }
                            }
                        }
                        // to decay this scent, add a negative amount
                        //   start with current intensity
                        //   multiply by decay rate configuration parameter (eg. 0.8 => 20% loss)
                        //   multiply by (number of open directions+1)/5
                        //     (narrow corridors dissipate more slowly than open space)
                        //     (if we don't do this, feedback from neighbors will actually make dissipation slower in open spaces)
                        //       4 sides open 100% .. 3 sides open 80% .. 2 sides open 60% .. 1 side open 40% .. closed room 20%
                        AddToNextScentIntensity(c, s, -orig_intensity * cfg.ScentDecayRate * ((spread_count + 1) / 5));
                    }
                }
                yield return null;  // once per room to leave time for other activities.
            }

            // now, transfer all those NextScents back to Scents.
            foreach (Room room in rooms)
            {
                foreach (Cell cell in room.cells)
                {
                    if (cell.scents == null) cell.scents = new();

                    for (int scent_num = 0; scent_num < cell.scents.Count; scent_num++)
                    {
                        // only keep scent if above cfg.ScentMinimum
                        if (cell.scents[scent_num].nextIntensity >= cfg.ScentMinimum)
                        {
                            cell.scents[scent_num].intensity = cell.scents[scent_num].nextIntensity;
                            cell.scents[scent_num].nextIntensity = 0; // clear for next pass
                        }
                        else
                        {
                            cell.scents.RemoveAt(scent_num);
                            scent_num--;
                        }
                    }

                }
                yield return null;   // once per room to leave time for other activities.
            }
        }
    }

    void AddToNextScentIntensity(Cell c, int agent_id, float added_intensity)
    {
        if (c.nextScents == null) c.nextScents = new();

        // if we find a matching agentId, add the scent amount
        for (int scent_num = 0; scent_num < c.nextScents.Count; scent_num++)
        {
            if (c.scents[scent_num].agentId == agent_id)
            {
                c.scents[scent_num].nextIntensity += added_intensity; //orig_scent.intensity * cfg.ScentSpreadAmount;
                return;   // found a match so we are done.
            }
        }

        // matching AgentId not found, add a new scent to list;
        ScentClass new_scent = new ScentClass
        {
            agentId = agent_id,
            nextIntensity = added_intensity
        };
        c.scents.Add(new_scent);
    }

    Cell GetCellFromHf(int x, int y, int z, int threshold)
    {
        NeighborMatch match;
        if (hf.TryQueryAt(x, y + 1, z, threshold: 10, out match))
        {
            Room nRoom = rooms[match.roomId];
            foreach (Cell cc in nRoom.cells)
            {
                if ((cc.x == x) && (cc.y == y)) return cc;
            }
        }
        return null;
    }

    // =======================================================
    // helper routines
    // =======================================================
    //  Extra functions

    public String ListOfIntToString(List<int> ilist, bool do_sort = true)
    {
        String result = "List: ";
        if (do_sort) ilist.Sort();
        foreach (int i in ilist)
        {
            result = result + i + ",";
        }
        return result;
    }


    public Color getColor(Color? color = null, bool highlight = true, string rgba = "")
    {
        Color colorrgba = new(); //temp
        Color return_color = Color.white;

        if (color != null)
            return_color = (Color)color;
        else if ((!string.IsNullOrEmpty(rgba)) && (ColorUtility.TryParseHtmlString(rgba, out colorrgba)))
            return_color = colorrgba;
        else if (highlight)
            return_color = UnityEngine.Random.ColorHSV(0f, 1f, 0.6f, 1f, 0.6f, 1f);   // Bright Random
        else // highlight == false
            return_color = UnityEngine.Random.ColorHSV(0f, 1f, 0.6f, 1f, 0.1f, 0.4f); // Dark Random

        return return_color;
    }

} // End class DungeonGenerator
