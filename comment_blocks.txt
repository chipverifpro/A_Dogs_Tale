Assets/A_Dogs_Tale/Assets/Scripts/Battle/BattleAgent.cs:38-46
//IDEAS:
// Limit rotate speed, show rotation travel by rounded arrows
// Switch from straight target arrow to curved when power-up
// Combine functions into fewer classes.  Simplify.
// Show limits that move-in/out can be, and player's position within the range
// Effects for hit / miss
// Add keyboard controls
// Turn player in direction of travel, exposing side to enemy
// Show block

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/SniffModeVisuals.cs:6-12
/// <summary>
/// Controls "sniff mode" visual treatment:
/// - desaturates and darkens the world
/// - applies a purplish color tint
/// - adds vignette
/// - optional subtle blur via Depth of Field
/// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/SniffModeVisuals.cs:151-163
        // NOTE: to use the sniffFogBoost above...
        // In your fog material’s shader (ShaderGraph or HLSL), multiply your final output
        // by this global float:
        //
        /// float _SniffFogBoost;
        ///
        /// half4 Frag(Varyings IN) : SV_Target
        /// {
        ///     float4 col = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
        ///     col.rgb *= _SniffFogBoost;      // boost color
        ///     col.a   *= _SniffFogBoost;      // boost opacity (optional)
        ///     return col;
        /// }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:393-399
        // Before first pass, initialize flag about scents which are stable.  Any change will set this false.
 //       for (int i = 0; i < dir.scentRegistry.knownScentSources.Count; i++)
 //       {
 //           var scentSource = dir.scentRegistry.knownScentSources[i];
 //           scentSource.scentNextStabilized = true;
 //       }
        // FIRST PASS: compute deltas and accumulate into airNextDelta / groundNextDelta

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:550-559
                // check for stabilization
 //               if ((Mathf.Abs(scent.airNextDelta) > practically_zero) || (Mathf.Abs(scent.groundNextDelta) > practically_zero))
 //               {
 //                   //Debug.Log($"ScentAirGround: Scent scentSource {scent.agentId} is changing. Air delta = {scent.airNextDelta}, Ground delta = {scent.groundNextDelta}");
 //                   scent.agent.agentScentSource.scentNextStabilized = false;   // scent still changing.
 //               } 
 //               else
 //               {
 //                   //Debug.Log($"ScentAirGround: Scent scentSource {scent.agentId} appears stable this step.  Air delta = {scent.airNextDelta}, Ground delta = {scent.groundNextDelta}");
 //               }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:581-591
            // after second pass, look for stabilied scents.
 //           for (int i = 0; i < gen.scentRegistry.knownScentSources.Count; i++)
 //           {
 //               var scentSource = gen.scentRegistry.knownScentSources[i];
 //               if ((scentSource.scentNextStabilized == true) &&
 //                  (scentSource.scentStabilized == false))
 //               {
 //                   Debug.Log($"ScentAirGround: Scent scentSource {scentSource.agentId} has stabilized.");
 //                   scentSource.scentStabilized = true;
 //               }
 //           }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:606-612
        // Reset needed? We already reset these after changes applied.
        //               Also reset at initial creation.
        //               Could we have changed something elsewhere we shouldn't forget to apply?
        //anyScentAirChanged = false;
        //anyScentGroundChanged = false;
        //anyScentAirCreated = false;
        //anyScentGroundCreated = false;

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:780-784
 //       if (scentSource.scentStabilized)
 //       {
 //           Debug.LogWarning($"DepositScentToCell: scentSource {scentSource.agentId} is stabilized; no further scent will be deposited.");
 //           return;
 //       }

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentAirGround.cs:1010-1014
    /// <summary>
    /// Immediately hides all scent visuals (air + ground) by setting alpha to 0.
    /// Does not destroy any instances; they remain in ElementStore/Warehouse pools.
    /// Scent structures are also updated to reflect zero visualization.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:292-296
        // TODO: Implement integration with your ScentSystem & Cell layout:
        // - For the given cell, find all agentIds contributing scent there.
        // - Map agentId -> ScentSource via this registry.
        // - Compute airStrength / groundStrength / combinedStrength.
        // For now, just return an empty list stub.

---
Assets/A_Dogs_Tale/Assets/Scripts/Scents/ScentRegistry.cs:350-354
    /// <summary>
    /// Called when a particularly strong scent is present in the current cell,
    /// even if the player isn't actively sniffing.
    /// Should trigger a BottomBanner notice and may influence dog behavior.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:150-157
    // RegenerateDungeon is the main coroutine that handles dungeon generation.
    // It orchestrates the various steps involved in creating the dungeon layout.
    // Step 0: Select settings
    // Step 1: Initialize the dungeon
    // Step 2: Place rooms (ScatterRooms or CellularAutomata)
    // Step 3: Convert rooms to a list of floor tiles (ConvertRectToRoomPoints or findRoomTiles for CA)
    // Step 4: Combine overlapping rooms (MergeOverlappingRooms)
    // Step 5: Connect rooms by corridors (DrawCorridors)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:258-262
            // TAVERN
            //            if (tavern.enabled)
            //            {
            //                yield return StartCoroutine(BuildTavern(tm: null));
            //            }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:721-725
        //Debug.Log("SetTilemapWithTransforms");
        //Debug.Log($"pos     ={pos.ToString()}");
        //Debug.Log($"scale   ={scale.ToString()}");
        //Debug.Log($"offset  ={offset.ToString()}");
        //Debug.Log($"rotation={rotation.ToString()}");

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DungeonGenerator.cs:992-999
    // NEW
    /// <summary>
    /// Merge rooms that overlap (share at least one tile).
    /// If considerAdjacency is true, rooms that touch by edge/corner are merged too.
    /// </summary>
    /// <param name="rooms">Input rooms (each has List<Vector2Int> tiles)</param>
    /// <param name="considerAdjacency">If true, merge when tiles are neighbors (4- or 8-connected)</param>
    /// <param name="eightWay">If adjacency is considered, choose 4-way or 8-way</param>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:159-166
    // OLD style: quick lookup in multiple lists for floors, walls, heights.
    // HashSets allow fast check whether room contains something at a position.
    // See the functions below: bool IsTileInRoom(pos), bool IsWallInRoom(pos)
    // Dictionaries are also based on a hash but returns a value at that position.
    // int GetHeightInRoom_OLD(pos)
    //public HashSet<Vector2Int> floor_hash_room = new();
    //public HashSet<Vector2Int> wall_hash_room = new();
    //public Dictionary<Vector2Int, int> heights_lookup_room = new();

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:234-238
            //Debug.Log($"Building cell_dictionary_room.");
            // Build dictionary once and keep it.
            //   Auto-regenerates if "cells" list length changes.
            //   Note that you must manually call ResetCellDictionary()
            //   yourself if you modify the list

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:296-301
    // Set the color for the floor tiles in this room many ways...
    // room.setColorFloor(Color.white);        // White
    // room.setColorFloor(rgb: "#FF0000FF"); // Red
    // room.setColorFloor();                   // Bright Random
    // room.setColorFloor(highlight: false);   // Dark   Random
    // room.setColorFloor(highlight: true);    // Bright Random

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:393-398
        // (Optional) compute the maximum signed projection run from center to room edge
        // along the given direction; useful if you want to reason about max delta:
        // float hx = (b.width  - 1) * 0.5f;
        // float hy = (b.height - 1) * 0.5f;
        // float maxProjAbs = Mathf.Abs(dir.x) * hx + Mathf.Abs(dir.y) * hy;
        // float maxHeightDelta = slopePerTile * maxProjAbs;

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Room-Cell.cs:419-424
    /// <summary>
    /// Compute tilt Euler (pitch=x, yaw=y(=0), roll=z) with robust handling of missing neighbors.
    /// Pass null for any neighbor that doesn't exist.
    /// h* are in grid height units; heightUnit converts to world units.
    /// edgeTiltScale in [0..1]: 1 = full one-sided tilt, 0 = flatten at edges.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:179-183
                // Out of inline capacity: fall back to segment building path by forcing finalize to SegmentVec
                // We temporarily append "at the end" (not sorted) and let FinalizeColumns fix it.
                // Reuse last slot to mark overflow; we'll re-sort later.
                // For correctness right now, replace the farthest z to keep n constant.
                // (Corner case; will be fixed in FinalizeColumns.)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:501-522
        /// <summary>
        /// Returns which sides of (x,y,z) are exposed (i.e., need walls/railings), as DirFlags.
        /// Coordinates are grid-space; z is the discretized height used by Heightfield.
        /// 
        /// Conventions:
        ///   North = (x,   y+1)
        ///   South = (x,   y-1)
        ///   West  = (x-1, y  )
        ///   East  = (x+1, y  )
        /// </summary>
        /// <param name="hf">Built/Finalized Heightfield</param>
        /// <param name="x">Cell X</param>
        /// <param name="y">Cell Y</param>
        /// <param name="z">Cell height (int units consistent with hf)</param>
        /// <param name="threshold">Typically cfg.minRoomHeightInt</param>
        /// <param name="currentRoomId">
        ///   Room id of the floor at (x,y,z). If unknown, pass -1 to disable inter-room policies.
        /// </param>
        /// <param name="policy">How to treat neighbors (see NeighborPolicy)</param>
        /// <param name="treatBoundsAsWalls">
        ///   If true, map edges (out of bounds) are considered walls on that side.
        /// </param>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:579-583
                        // If your world can have multiple segments at the same column height range,
                        // treat crossings between distinct segments as needing a barrier/rail.
                        // Here we use segmentIndex (valid when isSegment==true). If the current
                        // column also has segments and the current z lies in a different one than
                        // neighbor, count it as exposed. We need our own segment index at (x,y,z):

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/Heightfield.cs:609-637
    // --------------------------
        // Adapters to YOUR data
        // --------------------------
        //
        // 1) If your heights are float, choose a scale (e.g., 100) and round: zInt = Mathf.RoundToInt(zFloat * scale).
        // 2) If your world is big, build per-chunk Heightfield instances (e.g., 64x64) and query only active chunks.
        //
        // Example usage in your pipeline:
        //
        //   // Prepare cells from your rooms:
        //   var tmp = new List<RoomCell>(totalCellCount);
        //   foreach (var room in rooms)
        //       foreach (var cell in room.tiles3D) // (x,y,height)
        //           tmp.Add(new RoomCell(cell.x, cell.y, HeightToInt(cell.height), room.id));
        //
        //   // Build
        //   var hf = Heightfield.BuildFromCells(tmp, worldWidth, worldHeight, cfg.minRoomHeight);
        //
        //   // During wall placement for a floor cell (x,y,zInt):
        //   NeighborMatch m;
        //   bool hasNeighbor = hf.HasAdjacentWithinThreshold(x, y, zInt, cfg.minRoomHeight, out m);
        //   if (!hasNeighbor) {
        //       // exposed side -> place wall
        //   } else {
        //       // Optional: decide based on room ids or m.isSegment (e.g., railing for stairwell)
        //   }
        //
        // Helper for float heights:
        // static int HeightToInt(float z) => Mathf.RoundToInt(z * 100f); // choose a scale that matches your thresholds

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/DataStructures/DisjointSetUnion.cs:3-7
//public static class DSU
//
// Simple Union-Find/Disjoint Set (DSU=Disjoint Set Union)
// Created by ChatGPT, for MergeOverlappingRooms function.
// Will probably re-write this using existing hashes.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering2DMap/Tilemap2D.cs:160-164
                                                         // Clear visuals;
                                                         //if (replacementTile != null)
                                                         //tilemap.SetTile(pos, replacementTile);
                                                         //else
                                                         //ClearTileAndNeighborWalls(tilemap, pos);

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering2DMap/Tilemap2D.cs:185-189
            // 1) Find Floor clusters
            // we already found the rooms, just filter them out for tiny ones.
            //rooms = new List<Room>();
            //yield return StartCoroutine(FindClustersCoroutine(map, FLOOR, rooms, tm: null));
            // 2) Remove the tiny ones by turning them into WALL

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/Rendering3D/HeightMap3DBuilder.cs:10-14
    //[Header("3D Build Settings")]
    //    public float unitHeight = 0.1f;             // world Y per step
    //    public bool useDiagonalCorners = true;
    //    public bool skipOrthogonalWhenDiagonal = true;
    //    public int perimeterWallSteps = 30; // height of perimeter walls in steps

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonBuildSettingsJson.cs:77-83
// Example usage:
//
// Save current settings
// settings.SaveToJsonFile("MyPreset");
//
// Load (overwrite current instance fields)
// settings.LoadFromJsonFileOverwrite("MyPreset");
---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonGUISelector.cs:80-86
        // ----- ENUM PATH (recommended) -----
        // Assumes your DungeonSettings contains:
        //   public RoomAlgorithm roomAlgorithm;
        //   public TunnelAlgorithm tunnelsAlgorithm;
        // …and the enums:
        //   public enum RoomAlgorithm { BSP, Cellular, Drunkard, PrefabRooms, … }
        //   public enum TunnelAlgorithm { Straight, LSystem, AStarCarve, … }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/BuildMenus/DungeonGUISelector.cs:172-180
    // If you store strings in cfg instead of enums:
    // static void PopulateDropdownFromList(TMP_Dropdown dd, IList<string> items)
    // {
    //     dd.options.Clear();
    //     for (int i = 0; i < items.Count; i++)
    //         dd.options.Add(new TMP_Dropdown.OptionData(items[i]));
    //     dd.value = 0;
    //     dd.RefreshShownValue();
    // }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:159-166
    //  IEnumerator Corridors_DrunkardsWalk()
    //  {
    //      BottomBanner.Show("Corridors: DrunkardsWalk");
    //      // 1) lay 'cfg.corridor.spineCount' biased random walks with width 'cfg.corridor.corridorWidth'
    //      // 2) optionally connect keypoints with loops
    //      // 3) write into PackMap.corridors and lock a 1-cell moat if you keep thin walls
    //      yield return null;
    //     }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:168-175
    //    IEnumerator Corridors_WanderingMST()
    //    {
    //        BottomBanner.Show("Corridors: WanderingMST");
    //        // 1) lay 'cfg.corridor.spineCount' biased random walks with width 'cfg.corridor.corridorWidth'
    //        // 2) connect keypoints with MST + add loops with probability cfg.corridor.loopChance
    //        // 3) write into PackMap.corridors and lock a 1-cell moat if you keep thin walls
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:189-195
    //    IEnumerator Seed_AlongCorridors()
    //    {
    //        BottomBanner.Show("Seeding: AlongCorridors");
    //        // place seeds along corridor sides every cfg.seed.spacing with jitter cfg.seed.jitter
    //        // alternate left/right by cfg.seed.alternateSides
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:209-216
    //    IEnumerator Grow_CreditWavefront()
    //    {
    //        BottomBanner.Show("Growth: CreditWavefront");
    //        // each room gets random credit in [cfg.grow.areaCreditMin..Max]
    //        // round-robin claimable frontier respecting moat = cfg.grow.wallMoat
    //        // split if area>cfg.grow.splitArea or aspect>cfg.grow.splitAspect
    //        yield return null;
    //    }

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:230-235
    //IEnumerator Scraps_VoronoiFill()
    //{
    //    BottomBanner.Show("Scraps: VoronoiFill");
    //    // assign leftovers to nearest room with 1-cell peel for walls; tiny islands -> closets
    //    yield return null;
    //}

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:765-769
    // ROOM READY
    // Grow_CreditWavefrontStrips() repeatedly expands rooms in one direction by a full length row or column.
    //   This keeps rooms rectangular (as opposed to just CreditWavefront (obsolete/removed)).
    // allowedRoomIds list can optionally be provided to limit which rooms to grow.
    //   allowedRoomIds is unused in first pass of growth.  Used in repeated passes of growth to only grow new seeds.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:773-777
        // PRECONDITIONS:
        // - rooms is a global variable that contains all Room objects
        // - Each Room has at least one seed Cell in cellGrid[,] with cell.roomId = room.id
        // - Corridors already painted (cell.isCorridor = true)
        // - We will preserve an N-cell wall moat (N = cfg.grow.wallMoat) around rooms & corridors

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:958-964
    // ======================= Scraps: VoronoiFill (with 1-cell peel) =======================
    // Usage:
    //   yield return StartCoroutine(Scraps_VoronoiFill(
    //       moatOverride: -1,      // -1 => use cfg.grow.wallMoat
    //       useCentroids: true,    // false => use first seed cell as proxy
    //       peelIterations: 1,     // run peel pass N times (1–2 is enough)
    //       yieldEvery: 2048));

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1139-1149
    // ======================= Scraps: Seed & Grow Until Packed =======================
    // Usage example:
    //   yield return StartCoroutine(Scraps_SeedAndGrowUntilPacked(
    //       mode: ScrapSeedMode.PerimeterEveryN,
    //       perimeterSpacing: 10,
    //       randomSeedsPerRegion: 3,
    //       randomMinSpacing: 6,
    //       maxRounds: 6,
    //       moatOverride: -1,             // -1 uses cfg.grow.wallMoat
    //       yieldEvery: 2048
    //   ));

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1518-1523
    // ROOM READY
    // Checks if the room is big enough and stretched enough to split.
    // Determines where to cut the room.
    // Performs the cut: moat cells removed, left side kept in old room, right side moved to a new room.
    // Add new room to master rooms list
    // Update the screen, calculate new bounds and frontiers.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1700-1704
    // ROOM READY
    // score depends on the length-to-height ratio modified by the targetAsp parameter,
    //                  the cooldown penalty for that direction,
    //                  a preference for the short axis.
    // Return sides in best-first order: 0:E,1:W,2:N,3:S

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:1790-1794
    // Unused.
    // Wavefront helpers (compactness-biased pick).
    // Selects best cell in frontier, based on score:
    //    SCORE: -3: not close to corridor
    //           +2: adjacent to more cells in the same room

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2006-2010
    // ROOM READY
    // Pick a tangent direction at (x,y) by counting how many contiguous corridor
    // cells exist to the Left/Right/Down/Up (L/R/D/U). Wider corridors are handled
    // because we look past a single neighbor. Returns (1,0) for horizontal,
    // (0,1) for vertical, or Vector2Int.zero if nothing usable is found.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomPackedAlgorithms.cs:2045-2051
    // ROOMS ready
    // Returns the number of cells that continue to be a corridor in a given
    //   direction (d) from starting point (s).
    // Only looks as far as maxSteps.
    // Used in Seed_AlongCorridors via the PickTangentDir and CountCorridorNeighbors functions
    //   to determine which directions the corridor goes from a given location
    //   (since corridors can be wide we need to look farther).

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomGrowthAlgorithms.cs:8-14
    // Cellular Automata Algorithm:
    // 1. Fill a 2D map with random or noisy structured data (perlin noise).
    // 1a. Threshold the 2D map into only floors and walls
    // 2. Run the game of life on the cells using rules about survivability based on number of neighbors,
    //    through several iterations (smoothes out areas, gives structure to noise)
    // 3. Clean up result (remove tiny areas (rooms or rocks), replace solid wall fields with void.
    // 4. Convert result into Rooms.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/LineGenerators.cs:6-18
    // --------- Corridor line algorithms ----------
    // These return a list of points, which the DrawCorrior function will follow
    // while handling the width and slope to generate a corridor Room:
    //
    //   ORTHOGONAL (straight in cardinal directions only, one 90 degree bend)
    //   BRESENHAM (straight direct between end points)
    //   NOISY BRESENHAM (slightly wiggly version of a straight line)
    //   ORGANIC (kinda jiggles while going 45 degrees and then vertical or horizontal)
    //   BEZIER (curved quadratic form with two random control points)
    //
    //   future: STAIRS in versions that are straight, square, octagon, or switchback
    //           primarily for going up and down one or more a vertical floors
    //   future: LADDER (vertical only), or PIT or SHAFT or ELEVATOR or...

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomScatterAlgortithms.cs:6-20
// ---------------------- Room Scatter Algorithms ----------------
// ScatterRoom handles either rectangular or oval rooms that are randomly scattered.
// They can be configured to overlap or not.  Overlaps can either merge into an odd
// shaped room, or have different elevations allowing one above the other, or if
// vertical distance is small enough, they will have an elevation between them (cliff
// or steps).
//
// Future: COMPACT: rooms will all touch each other in a contiguous area.
//         They may have thin or thick walls.
// Future: Rooms may have functional purposes and have specific connection rules,
//         like Tavern which has a common area, a service area, and a private area,
//         each consisting of several named rooms.
//
// -------------------- room rect functions -----------------------------
// This file also contains a bunch of routines that deal with room_rects.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldBuilder/GenerationAlgorithms/RoomScatterAlgortithms.cs:86-92
    // Returns true if the proposed room bounds fit inside the world according to config flags.
    // (1) cfg.ovalRooms   — RectInt room treated as an inscribed axis-aligned ellipse when true.
    // (2) cfg.roundWorld — world bounds are an axis-aligned ellipse inscribed in the map when true;
    //                       otherwise world is the rectangular map.
    // "samples" controls boundary sampling for oval-in-oval; "margin" shrinks world a bit to avoid edge bleed.
    // 
    // Works for: Rect in Rect, Oval in Rect, Rect in Oval, and Oval in Oval.

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/WarehouseGO.cs:5-9
/// <summary>
/// Holds the fully manufactured GameObjects for a built environment.
/// ManufactureGO populates this from ElementStore.
/// Later, some layers can move to GPU-only, but this class stays the "registry".
/// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:52-57
/// <summary>
/// Describes the "recipe" or archetype for a family of elements.
/// Think of this as prefab-like data BEFORE it becomes an actual GameObject.
/// ManufactureGO will use this to decide which prefab/mesh/material to use,
/// or how to feed data into GPU instancing.
/// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:192-197
/// <summary>
/// Central store of all environment element definitions and logical instances.
/// This is purely data - no GameObjects here.
/// ManufactureGO will read from this to create actual GameObjects / GPU instances,
/// and WarehouseGO will own the manufactured results.
/// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:550-554
        // Optional: validate before trying to build
        //if (!elementStore.TryGetArchetype(inst.archetypeId, out _)) {
        //    Debug.LogError("AddScentGround: archetype {inst.architypeId} not registered. Register it before calling AddScentGround.");
        //    return -1;
        //}

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ElementStore.cs:658-663
    /// <summary>
    /// Change the color of a specific instance and mark it dirty so
    /// ManufactureGO.ApplyPendingUpdates can push it into the live GameObject.
    /// Returns true if an instance was found and changed.
    /// </summary>
    // If we have cell and scent, no searching for them needed in ChangeColor()

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ManufactureGO.cs:5-10
/// <summary>
/// Converts logical data in ElementStore into manufactured GameObjects
/// under a WarehouseGO. For now this is a straightforward Instantiate-like
/// builder using ElementArchetype.mesh/material and ElementInstanceData.
/// Later, some layers can be switched to GPU-only (instancing/indirect).
/// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldData/ManufactureGO.cs:215-219
    /// <summary>
    /// Apply any pending changes in ElementStore (based on dirtyFlags)
    /// to the already manufactured GameObjects in WarehouseGO.
    /// Currently supports Color; can be extended for transforms, etc.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioCatalog.cs:55-59
// class AudioCatalog contains a master list of all audio available
//  to the game.  All that is needed is to call PlayClip() with
//  the name of the track, and it handles everything else.
// It will eventually import this from some configuration file,
//  maybe a .csv, a .json, or from the directory itself.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:63-69
    // PlayClip() finds the audio clip in the master catalog (clipCfgList),
    //  configures everything, and then launches the Coroutine
    //  PlayWithInterval() which starts the play and follows
    //  it through it's lifecycle.
    // Each entry in the master catalog (a unique "clipCfg") maintains
    //  a list of currently playing copies so they can be ended
    //  anytime needed.

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:170-174
    // PlayWithInterval() will handle all cases of plaing a track.
    //   whether single time, continuous repeat, or
    //   repeat forever with fixed or random pauses between.
    // A TaskInfo structure is maintained so that tasks and audio 
    //   can be stopped if needed (ie. scene change, sound source disappears, etc)

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:251-256
    // StopClips() has several options...
    //  Stop everything
    //  Stop all with a particular name
    //  Stop all on a particular channel (ie Music, UI, SFX, ...)
    //  Stop all from a particular GameObject
    //  Stop all from all temporary GameObjects

---
Assets/A_Dogs_Tale/Assets/Scripts/MusicAndSFX/AudioPlayer.cs:295-304
    // Don't call coroutine AudioTaskStop() directly, use StopClips() above
    //   which applies a lookup filter to select tasks and remove them from the active
    //   list, and send control of them here to be managed until they are done.
    // task.AudioTaskStop():  Corourtine that stops managed track by stopping existing driver
    //   coroutine, then it takes over managing the track until it has stopped. Finally
    //   it destroys the GameObject if it is a temporary one created just for this audio.
    // Can end in one of these styles:
    //   Immediate cutoff of playing. (fadeOut = 0)
    //   Fade out and then stop.      (fadeOut = # seconds)
    //   Allow to finish in-progress track, but don't start again. (fadeOut < 0)

---
Assets/A_Dogs_Tale/Assets/Scripts/WorldObjects/WorldObjectRegistry.cs:52-56
    /// <summary>
    /// Register a WorldObject. If it already has a valid ID and that ID is free, we honor it.
    /// Otherwise we assign the next available ID.
    /// </summary>
    /// <returns>The ID assigned to this object, or -1 on failure.</returns>

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:7-12
// TODO list:
//   DONE: add movement on diagonal walls
//   DONE add start on map floor tile
//   DONE: add height to movement
//   switch to heightmap instead of grid to allow movement with vertical stacking
//   move all params into this file.

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Player.cs:173-183
            //    
            //    dir.scents.AddScentToCell(player_cell,
            //                                    agentId: 1,
            //                                    airAmount: 1f,
            //                                    groundAmount: .1f);
                //Debug.LogError($"[AddScent] Player is in cell {agent.pos2.x}, {agent.pos2.y}, room {player_cell.room_number}");
                //dir.scents.AddToNextScentIntensity(
                //    player_cell,        // cell
                //    1,                  // phony agent_id  // TODO: link to real agent id
                //    set_intensity: 1.0f // set a value, not add a value
                //);

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:135-140
                    //Debug.Log($"Depositing scent from AgentId = {id} at {pos2_int}: air += {agentScentSource.airDepositRate}, ground += {agentScentSource.groundDepositRate}");
 //                   if (agentScentSource.scentStabilized == true)
 //                   {
 //                       agentScentSource.scentStabilized = false;
 //                       Debug.Log($"AgentScentEmmiter: AgentId {id} scent unstabilized due to new deposit.");
 //                   }

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:602-619
//        }
//        else
//        {
//            Vector3 t; // = transform.position; // not necessary, we overwrite this value completely
//            Vector2 t_World = Map_to_World(agent.pos2);
//            t.x = t_World.x; t.y = t_World.y; // XY location
//            t.z = agent.height + 1;
//            agent.transform.position = t;
//            agent.targetYawDeg = agent.yawDeg;
//            TurnTowards(ref agent.yawDeg, agent.prevYawDeg, agent.targetYawDeg, agent.turnSpeedDegPerSec);
//            agent.prevYawDeg = agent.yawDeg;
//            agent.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Z for XY
//            if (pack.player.agent == agent)
//            {
//                pack.player.transform.position = t;
//                pack.player.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Y for 3D
//            }                                                                                       //pack.player.transform.rotation = Quaternion.Euler(0f, 0f, agent.yawDeg + yawCorrection); // rotate around Z for XY
//        }

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/Agent.cs:707-713
    // Assumptions:
    // - agentPos is in tile/grid coordinates (1 unit per cell) on the XZ plane → (x,z) == (agentPos.x, agentPos.y)
    // - cellGrid[x,y] gives you the Room.Cell that contains:
    //     int height;                // base floor height at the cell center
    //     Quaternion tiltFloor;      // tilt of the floor plane
    // - Y is world up.
    // cellGrid dimensions are W x H

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:425-429
    /// <summary>
    /// Distance from startWorld along dirWorld (normalized XZ) to the diagonal-corner wall
    /// inside the given cell, already accounting for playerRadius (no extra subtract needed).
    /// Returns true and sets 'distance' if hit; false if no diagonal in cell or ray misses.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Moving.cs:456-463
        // Cell's world-space min corner (bottom-left in your grid)
        //float xMin = room.bounds.xMin + (cellXY.x - room.bounds.xMin) * cellSize;
        //float zMin = room.bounds.yMin + (cellXY.y - room.bounds.yMin) * cellSize;
        // If you store absolute tile coords (not relative to bounds), use:
        //float xMin = (startWorld.x % 1f) * cellSize;
        //float zMin = (startWorld.y % 1f) * cellSize;
        //CleanupFloat(ref xMin, true);
        //CleanupFloat(ref zMin, true);

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Pathfinding.cs:36-40
    /// <summary>
    /// A* path from start to goal across 8 directions.
    /// Uses CanMoveInDirection(start, dir): returns >0 cost if open, 0 if blocked.
    /// Returns a list of tile coords including start and goal. Empty if no path.
    /// </summary>

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Pathfinding.cs:324-335
    /// // Suppose you have a RoomCells that implements IRoomCells
    /// 
    /// How to use:
    /// 
    /// IRoomCells room = currentRoom;
    ///
    /// bool los = LOS2D.HasLineOfSightInRoom(
    ///    room,
    ///    startWorldPosition,
    ///    endWorldPosition,
    ///    agentRadius: 0.4f // optional: expands walls by ~one cell if cellSize≈0.5
    /// );

---
Assets/A_Dogs_Tale/Assets/Scripts/Player/PlayerMovement/Pathfinding.cs:485-489
/// Usage:
/// // aWorld and bWorld in world XZ? Convert to tile coords first:
/// Vector2Int ToTile(Vector3 world, Vector3 origin, float cellSize) =>
///     new(Mathf.FloorToInt((world.x - origin.x)/cellSize),
///        Mathf.FloorToInt((world.z - origin.z)/cellSize));

---
